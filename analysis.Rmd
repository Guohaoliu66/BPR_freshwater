---
  title: "Global BPR pattern in freshwaters"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#1.0 Import data
```{r}

setwd("D:/Desktop/Data/raw data")
library(readxl)
library(vegan)
library(FD)
library(readxl)
library(ggplot2)
library(rstatix)
library(dplyr)
library(ggpubr)
library(ggsignif)
library(data.table)
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
#result <- data %>%  group_by(Dataset) %>% summarise(Data = first(Data),   Organism = #first(Organism),   X = mean(X, na.rm = TRUE), Y = mean(Y, na.rm = TRUE)         )
#write.csv(result, file = "D:/Desktop/Data/R/output/Average_Coordinates.csv")
```

# Cor
```{r}
library(dplyr)
library(purrr)
library(tidyr)

data <- data %>%
  filter(!(Dataset %in% c("AP05","AP06","AP07","AP08")))

# 设置目标变量
index_vars <- c("Richness", "Shannon", "FRic", "FDis")

# 生成所有两两组合
var_pairs <- t(combn(index_vars, 2)) %>% as.data.frame()
colnames(var_pairs) <- c("Var1", "Var2")

# 函数：对一个子数据集计算所有变量对的相关性和p值
get_cor_results <- function(df, dataset_name) {
  results <- map2_dfr(var_pairs$Var1, var_pairs$Var2, function(x, y) {
    x_vals <- df[[x]]
    y_vals <- df[[y]]
    if (sum(!is.na(x_vals) & !is.na(y_vals)) >= 3) {  # 至少3个点才计算
      test <- cor.test(x_vals, y_vals, method = "pearson")
      tibble(
        Dataset = dataset_name,
        Var1 = x,
        Var2 = y,
        R_value = round(test$estimate, 3),
        P_value = round(test$p.value, 4)
      )
    } else {
      tibble(
        Dataset = dataset_name,
        Var1 = x,
        Var2 = y,
        R_value = NA_real_,
        P_value = NA_real_
      )
    }
  })
  return(results)
}

# 主计算：按 Dataset 分组，汇总所有结果
cor_results_all <- data %>%
  group_by(Dataset) %>%
  group_split() %>%
  map_dfr(~ get_cor_results(.x, unique(.x$Dataset)))

# 查看结果
cor_results_all <- cor_results_all %>%
  mutate(label = case_when(
    is.na(P_value) ~ "",
    P_value <= 0.001 ~ "***",
    between(P_value, 0.001, 0.01) ~ "**",
    between(P_value, 0.01, 0.05) ~ "*",
    TRUE ~ ""
  ))

cor_results_all <- cor_results_all %>%
  mutate(
    Var1 = case_when(
      Var1 == "Richness" ~ "Rich",
      Var1 == "Shannon" ~ "H'",
      TRUE ~ Var1
    ),
    Var2 = case_when(
      Var2 == "Richness" ~ "Rich",
      Var2 == "Shannon" ~ "H'",
      TRUE ~ Var2
    ),
    Index_Pair = paste(Var1, Var2, sep = " ~ ")  # 更新 Index_Pair 标签
  )
cor_results_all <- cor_results_all %>%
  mutate(Index_Pair = paste(Var1, Var2, sep = " ~ "))

# Step 2：绘制热图
ggplot(cor_results_all, aes(y = Dataset, x = Index_Pair)) + 
  geom_tile(aes(fill = R_value), colour = "grey", size = 0.5) +
  scale_fill_gradient2(low = "#5C5DAF", mid = "white", high = "#ffc48a", limits = c(-1, 1)) +
  geom_text(aes(label = label), color = "black", size = 5, vjust = 0.8) +
  scale_y_discrete(limits = rev)+
  theme_minimal() +
  theme(
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0, size = 10),
    axis.text.y = element_text(size = 9)
  ) +
  labs(fill = paste0("***  p < 0.001\n",
                     "**   p < 0.01\n",
                     "*    p < 0.05\n\n",
                     "Correlation (R)")) +
  scale_x_discrete(limits = rev,position = "top")

ggsave("D:/Desktop/Data/R/output/Cor.pdf",  width = 6, height = 10)
```

# sta
```{r}
data <- read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")
df_summary <- data %>%
  group_by(Data, Relationship_Type_Shannon) %>%
  summarise(count = n(), .groups = "drop")
```

#Cor 2
```{r}
cor_results_all <- cor_results_all %>%
  mutate(
    # 创建组合名（X轴）
    Index_Pair = paste(Var1, Var2, sep = " ~ "),
    
    # 设置星号 label，纵向排列
    label = case_when(
      is.na(P_value) ~ "",
      P_value <= 0.001 ~ "*\n*\n*",   # 三星
      P_value <= 0.01 ~ "*\n*",       # 二星
      P_value <= 0.05 ~ "*",          # 一星
      TRUE ~ ""
    )
  )

# 绘图
ggplot(cor_results_all, aes(x = Dataset, y = Index_Pair)) + 
  geom_tile(aes(fill = R_value), colour = "grey", size = 0.5) +
  scale_fill_gradient2(
    low = "#5C5DAF", mid = "white", high = "#ffc48a",
    limits = c(-1, 1), name = "Correlation (R)"
  ) +
  geom_text(
    aes(label = label),
    color = "black",
    size = 5,
    lineheight = 0.4      # 控制星号之间距离
  ) + 
  theme_minimal(base_size = 14) +
  theme(
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.8, size = 7),
    axis.text.y = element_text(size = 12),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5)
  )  +
  scale_x_discrete(position = "bottom")+
  labs(fill = paste0("***  p < 0.001\n",
                     "**   p < 0.01\n",
                     "*    p < 0.05\n\n",
                     "Correlation (R)"))

ggsave("D:/Desktop/Data/R/output/Cor2.pdf",  width = 11, height = 5)

r_value_range <- cor_results_all %>%
  group_by(Var1, Var2) %>%
  summarise(
    R_min = min(R_value, na.rm = TRUE),
    R_max = max(R_value, na.rm = TRUE)
  ) %>%
  ungroup()

```


# Preprocess(Scale_TP, Relative_Richness, Area, Num)
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
# 加载必要的包
library(GeoRange)
library(dplyr)

calculate_chull_area <- function(df) {
  if (nrow(df) < 3) {
    return(NA)  # 凸包计算至少需要3个点
  } else {
    return(CHullAreaEarth(df$X, df$Y))
  }
}

# 按Dataset分组，计算凸包面积
result <- data %>%
  group_by(Dataset) %>%
  summarise(CHullAreaEarth = calculate_chull_area(cur_data()))

# 将结果合并回原数据
data <- left_join(data, result, by = "Dataset")

data$logTP <- ifelse(data$TP > 0, log(data$TP), NA)
#write.csv(data, file = "D:/Desktop/Data/R/output/All_data.csv")


#Num
dataset_counts <- table(data$Dataset)

# 将结果转换为数据框
result <- as.data.frame(dataset_counts)
colnames(result) <- c("Dataset", "Num")  # 重命名列
data <- left_join(data, result, by = "Dataset")
#write.csv(data, file = "D:/Desktop/Data/R/output/All_data.csv")
```

# Description (Figure 1) 
```{r}
library(ggplot2)
library(gridExtra)


logTP=log(data$TP)
dataset_medians <- data %>%
  group_by(Dataset) %>%
  summarise(
    Data = first(Data),  # 取每组的第一个 Data 值
    Organism = first(Organism),  # 取每组的第一个 Organism 值
    Median_Area = median(Area, na.rm = TRUE),
    Median_TP = median(TP, na.rm = TRUE),
    Median_Elevation = median(Elevation, na.rm = TRUE),
    Median_AT = median(AT, na.rm = TRUE),
    Median_AP = median(AP, na.rm = TRUE),
    Median_TS = median(TS, na.rm = TRUE),
    Median_PS = median(PS, na.rm = TRUE),
    Median_n = median(Num, na.rm = TRUE),
    Median_Absolute_Latitude = median(abs(Y), na.rm = TRUE)
  )

dataset_medians <- dataset_medians %>%
  filter(!(Dataset %in% c("LETBM", "RNEBM", "RKEBD")))

custom_theme <- theme_minimal() +
  theme(
    panel.border = element_blank(),          # 去掉内框
    axis.line.x = element_line(color = "black"),  # 添加下框线
    axis.line.y = element_line(color = "black"),  # 添加左框线
    panel.grid = element_blank(),            # 去掉网格线
    axis.ticks = element_line(color = "black"),   # 添加刻度线
    axis.text = element_text(color = "black")     # 确保刻度文字显示
  )


# 图表2：Median TP
p1 <- ggplot(dataset_medians, aes(x = Median_TP)) +
  geom_histogram(bins = 12, fill = "#547ac0", color = "white") +
  labs(x = "Total Phosphorus (µg/L) ", y = "Number of Datasets") +
  custom_theme

# 图表1：Median Area (log-transformed)
p2 <- ggplot(dataset_medians, aes(x = log(Median_Area))) +
  geom_histogram(bins = 12, fill = "#547ac0", color = "white") +
  labs(x = "Area (log [km²])", y = "Number of Datasets") +
  custom_theme

# 图表3：Median Elevation
p3 <- ggplot(dataset_medians, aes(x = Median_Elevation)) +
  geom_histogram(bins = 12, fill = "#547ac0", color = "white") +
  labs(x = "Elevation (m)", y = "Number of Datasets") +
  custom_theme

# 图表4：Median AT
p4 <- ggplot(dataset_medians, aes(x = Median_AT)) +
  geom_histogram(bins = 12, fill = "#547ac0", color = "white") +
  labs(x = "Median Annual Temperature (°C)", y = "Number of Datasets") +
  custom_theme

# 图表5：Median AP
p5 <- ggplot(dataset_medians, aes(x = Median_AP)) +
  geom_histogram(bins = 12, fill = "#547ac0", color = "white") +
  labs(x = "Annual Precipitation (mm)", y = "Number of Datasets") +
  custom_theme

# 图表6：Median Absolute Latitude
p6 <- ggplot(dataset_medians, aes(x = Median_Absolute_Latitude)) +
  geom_histogram(bins = 12, fill = "#547ac0", color = "white") +
  labs(x = "Absolute Latitude (°)", y = "Number of Datasets") +
  custom_theme

#output_path <- "D:/Desktop/Data/R/output/Mean.pdf"
#pdf(output_path, width = 7, height = 5)  # 设置文件名和页面尺寸
grid.arrange(p1, p2, p3, p4, p5, p6, ncol = 3)  # 绘制图表
#dev.off()  

organism_data_summary <- dataset_medians %>%
  group_by(Organism, Data) %>%
  summarise(Count = n(), .groups = "drop")

# 按 Organism 计算总数量并排序
organism_order <- organism_data_summary %>%
  group_by(Organism) %>%
  summarise(Total_Count = sum(Count)) %>%
  arrange(desc(Total_Count)) %>%
  pull(Organism)


organism_data_summary$Organism <- gsub("Benthic Macroinvertebrate", "Benthic\nMacroinvertebrate", organism_data_summary$Organism)
organism_data_summary$Organism <- gsub("Benthic Diatom", "Benthic\nDiatom", organism_data_summary$Organism)

# 按 Organism 计算总数量并排序
organism_order <- organism_data_summary %>%
  group_by(Organism) %>%
  summarise(Total_Count = sum(Count)) %>%
  arrange(desc(Total_Count)) %>%
  pull(Organism)

# 调整 Organism 的顺序为从上到下（上多下少）
organism_data_summary$Organism <- factor(organism_data_summary$Organism, levels = rev(organism_order))

# 定义 Data 类别的颜色
custom_colors <- c("Lake" = "#99cbeb", "River" = "#547ac0") # 修改颜色为需要的两种

# 绘制柱状图
ggplot(organism_data_summary, aes(x = Count, y = Organism, fill = Data)) +
  geom_bar(stat = "identity", position = "stack") +
  scale_fill_manual(values = custom_colors) +  # 使用自定义的两种颜色
  labs(
    title = "Number of Datasets by Organism",
    x = "Number of Datasets",
    fill = "Waterbody type"
  ) +
  theme_minimal() +
  theme(
    legend.position = "top",                            # 图例位置调整到顶部
    legend.title = element_text(size = 10),             # 图例标题大小调整
    panel.grid.major = element_blank(),                 # 去掉网格线
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),                     # 去掉其他边框
    axis.line.x = element_line(color = "black"),        # 添加下框线
    axis.line.y = element_line(color = "black"),        # 添加左框线
    axis.ticks = element_line(color = "black"),         # 添加刻度线
    axis.text = element_text(color = "black")           # 确保轴文字显示
  )
#ggsave("D:/Desktop/Data/R/output/Organism2.pdf", device = "pdf", width = 3, height = 4)
```

# Shape define
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")

process_dataset <- function(df) {
  # 初始化默认值
  Remove <- FALSE
  Reason <- "Processed"

  # 步骤1：检查数据分布（仅报告，不剔除）
  skewness_logTP <- tryCatch({
    skewness(df$logTP, na.rm = TRUE)
  }, error = function(e) NA)

  sd_logTP <- sd(df$logTP, na.rm = TRUE)

  logTP_iqr <- IQR(df$logTP, na.rm = TRUE)
  logTP_q1 <- quantile(df$logTP, 0.25, na.rm = TRUE)
  logTP_q3 <- quantile(df$logTP, 0.75, na.rm = TRUE)
  logTP_outliers <- sum(df$logTP < (logTP_q1 - 1.5 * logTP_iqr) | 
                        df$logTP > (logTP_q3 + 1.5 * logTP_iqr), na.rm = TRUE)
  outlier_ratio <- logTP_outliers / nrow(df)

  # 数据分布特征记录
  distribution_info <- list(
    Skewness = skewness_logTP,
    Standard_Deviation = sd_logTP,
    Outlier_Ratio = outlier_ratio
  )

  # 步骤2：分析关系类型
  linear_model <- glm(Richness ~ logTP, data = df, family = gaussian())
  quadratic_model <- glm(Richness ~ logTP + I(logTP^2), data = df, family = gaussian())

  linear_aic <- AIC(linear_model)
  quadratic_aic <- AIC(quadratic_model)
  
  # AIC值差距不足10时，两个模型都进行关系判断
  if (abs(linear_aic - quadratic_aic) < 3) {
    linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
    linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
    quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
    quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]

    deviance_explained_linear <- (1 - linear_model$deviance / linear_model$null.deviance) * 100
    deviance_explained_quadratic <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

    if (linear_p < 0.1) {
      if (linear_coef > 0) {
        relationship_type <- "Positive Linear"
      } else {
        relationship_type <- "Negative Linear"
      }
      deviance_explained <- deviance_explained_linear
    } else if (quad_p < 0.1) {
      if (quad_coef < 0) {
        relationship_type <- "Unimodal"
      } else {
        relationship_type <- "Inverted Unimodal"
      }
      deviance_explained <- deviance_explained_quadratic
    } else {
      relationship_type <- "Non-significant"
      deviance_explained <- max(deviance_explained_linear, deviance_explained_quadratic)
    }
  } else {
    # 使用AIC值较低的模型进行关系判断
    if (quadratic_aic < linear_aic) {
      quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
      quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]
      deviance_explained <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

      if (quad_p < 0.1) {
        if (quad_coef < 0) {
          relationship_type <- "Unimodal"
        } else {
          relationship_type <- "Inverted Unimodal"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    } else {
      linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
      linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
      deviance_explained <- (1 - linear_model$deviance / linear_model$null.deviance) * 100

      if (linear_p < 0.1) {
        if (linear_coef > 0) {
          relationship_type <- "Positive Linear"
        } else {
          relationship_type <- "Negative Linear"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    }
  }

  # 返回结果
  return(list(
    Remove = Remove,
    Reason = Reason,
    Distribution_Info = distribution_info,
    Relationship_Type = relationship_type,
    Deviance_Explained = deviance_explained
  ))
}

# 应用到多个数据集
data_results <- lapply(split(data, data$Dataset), process_dataset)

# 提取结果为数据框
results_df <- data.frame(
  Dataset = names(data_results),
  Remove = sapply(data_results, function(x) x$Remove),
  Reason = sapply(data_results, function(x) x$Reason),
  Skewness = sapply(data_results, function(x) x$Distribution_Info$Skewness),
  Standard_Deviation = sapply(data_results, function(x) x$Distribution_Info$Standard_Deviation),
  Outlier_Ratio = sapply(data_results, function(x) x$Distribution_Info$Outlier_Ratio),
  Relationship_Type = sapply(data_results, function(x) x$Relationship_Type),
  Deviance_Explained = sapply(data_results, function(x) x$Deviance_Explained)
)

result <- data %>%
  group_by(Dataset) %>%
  summarise(
    Organism = first(Organism),
    Data = first(Data),
    Num = mean(Num, na.rm = TRUE),
    Area = mean(Area, na.rm = TRUE),
    Median_TP = median(TP, na.rm = TRUE),
    Median_AT = median(AT, na.rm = TRUE),
    Median_AP = median(AP, na.rm = TRUE),
    Median_Elevation = median(Elevation, na.rm = TRUE),
    Median_AL = median(AL, na.rm = TRUE),
    TP_Range = max(TP, na.rm = TRUE) - min(TP, na.rm = TRUE),
    AT_Range = max(AT, na.rm = TRUE) - min(AT, na.rm = TRUE),
    AP_Range = max(AP, na.rm = TRUE) - min(AP, na.rm = TRUE),
    Elevation_Range = max(Elevation, na.rm = TRUE) - min(Elevation, na.rm = TRUE),
    AL_Range = max(AL, na.rm = TRUE) - min(AL, na.rm = TRUE),
  ) %>%
  left_join(results_df, by = "Dataset") %>%
  distinct()


# 保留所有数据集并标注类型（不删除）
data <- data %>%left_join(result, by = "Dataset")

proportion <- result %>%
  group_by(Data, Relationship_Type_FRic) %>%
  summarise(Count = n(), .groups = 'drop') %>%
  group_by(Data) %>%
  mutate(Percentage = Count / sum(Count) * 100)

#write.csv(result, file = "D:/Desktop/Data/R/output/result.csv")
#write.csv(data, file = "D:/Desktop/Data/R/output/All_data.csv")
```

# Shape define Shannon
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data=data[!is.na(data$Shannon) & !is.na(data$logTP), ]


process_dataset <- function(df) {
  # 初始化默认值
  Remove <- FALSE
  Reason <- "Processed"

  # 步骤1：检查数据分布（仅报告，不剔除）
  skewness_logTP <- tryCatch({
    skewness(df$logTP, na.rm = TRUE)
  }, error = function(e) NA)

  sd_logTP <- sd(df$logTP, na.rm = TRUE)

  logTP_iqr <- IQR(df$logTP, na.rm = TRUE)
  logTP_q1 <- quantile(df$logTP, 0.25, na.rm = TRUE)
  logTP_q3 <- quantile(df$logTP, 0.75, na.rm = TRUE)
  logTP_outliers <- sum(df$logTP < (logTP_q1 - 1.5 * logTP_iqr) | 
                        df$logTP > (logTP_q3 + 1.5 * logTP_iqr), na.rm = TRUE)
  outlier_ratio <- logTP_outliers / nrow(df)

  # 数据分布特征记录
  distribution_info <- list(
    Skewness = skewness_logTP,
    Standard_Deviation = sd_logTP,
    Outlier_Ratio = outlier_ratio
  )

  # 步骤2：分析关系类型
  linear_model <- glm(Shannon ~ logTP, data = df, family = gaussian())
  quadratic_model <- glm(Shannon ~ logTP + I(logTP^2), data = df, family = gaussian())

  linear_aic <- AIC(linear_model)
  quadratic_aic <- AIC(quadratic_model)
  
  # AIC值差距不足10时，两个模型都进行关系判断
  if (abs(linear_aic - quadratic_aic) < 3) {
    linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
    linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
    quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
    quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]

    deviance_explained_linear <- (1 - linear_model$deviance / linear_model$null.deviance) * 100
    deviance_explained_quadratic <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

    if (linear_p < 0.1) {
      if (linear_coef > 0) {
        relationship_type <- "Positive Linear"
      } else {
        relationship_type <- "Negative Linear"
      }
      deviance_explained <- deviance_explained_linear
    } else if (quad_p < 0.1) {
      if (quad_coef < 0) {
        relationship_type <- "Unimodal"
      } else {
        relationship_type <- "Inverted Unimodal"
      }
      deviance_explained <- deviance_explained_quadratic
    } else {
      relationship_type <- "Non-significant"
      deviance_explained <- max(deviance_explained_linear, deviance_explained_quadratic)
    }
  } else {
    # 使用AIC值较低的模型进行关系判断
    if (quadratic_aic < linear_aic) {
      quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
      quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]
      deviance_explained <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

      if (quad_p < 0.1) {
        if (quad_coef < 0) {
          relationship_type <- "Unimodal"
        } else {
          relationship_type <- "Inverted Unimodal"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    } else {
      linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
      linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
      deviance_explained <- (1 - linear_model$deviance / linear_model$null.deviance) * 100

      if (linear_p < 0.1) {
        if (linear_coef > 0) {
          relationship_type <- "Positive Linear"
        } else {
          relationship_type <- "Negative Linear"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    }
  }

  # 返回结果
  return(list(
    Remove = Remove,
    Reason = Reason,
    Distribution_Info = distribution_info,
    Relationship_Type = relationship_type,
    Deviance_Explained = deviance_explained
  ))
}

# 应用到多个数据集
data_results <- lapply(split(data, data$Dataset), process_dataset)

# 提取结果为数据框
results_df <- data.frame(
  Dataset = names(data_results),
  Relationship_Type_Shannon = sapply(data_results, function(x) x$Relationship_Type),
  Deviance_Explained_Shannon = sapply(data_results, function(x) x$Deviance_Explained)
)

result <- data %>%
  group_by(Dataset) %>%
  summarise(
    Organism = first(Organism),
    Data = first(Data),
    Num = mean(Num, na.rm = TRUE),
    Area = mean(Area, na.rm = TRUE),
    Median_TP = median(TP, na.rm = TRUE),
    Median_AT = median(AT, na.rm = TRUE),
    Median_AP = median(AP, na.rm = TRUE),
    Median_Elevation = median(Elevation, na.rm = TRUE),
    Median_AL = median(AL, na.rm = TRUE),
    TP_Range = max(TP, na.rm = TRUE) - min(TP, na.rm = TRUE),
    AT_Range = max(AT, na.rm = TRUE) - min(AT, na.rm = TRUE),
    AP_Range = max(AP, na.rm = TRUE) - min(AP, na.rm = TRUE),
    Elevation_Range = max(Elevation, na.rm = TRUE) - min(Elevation, na.rm = TRUE),
    AL_Range = max(AL, na.rm = TRUE) - min(AL, na.rm = TRUE),
  ) %>%
  left_join(results_df, by = "Dataset") %>%
  distinct()


# 保留所有数据集并标注类型（不删除）
data <- data %>%left_join(result, by = "Dataset")

#write.csv(result, file = "D:/Desktop/Data/R/output/result_Shannon.csv")
#write.csv(data, file = "D:/Desktop/Data/R/output/All_data_Shannon.csv")


```


# Shape define FRic
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data=data[!is.na(data$FRic) & !is.na(data$logTP), ]


process_dataset <- function(df) {
  # 初始化默认值
  Remove <- FALSE
  Reason <- "Processed"

  # 步骤1：检查数据分布（仅报告，不剔除）
  skewness_logTP <- tryCatch({
    skewness(df$logTP, na.rm = TRUE)
  }, error = function(e) NA)

  sd_logTP <- sd(df$logTP, na.rm = TRUE)

  logTP_iqr <- IQR(df$logTP, na.rm = TRUE)
  logTP_q1 <- quantile(df$logTP, 0.25, na.rm = TRUE)
  logTP_q3 <- quantile(df$logTP, 0.75, na.rm = TRUE)
  logTP_outliers <- sum(df$logTP < (logTP_q1 - 1.5 * logTP_iqr) | 
                        df$logTP > (logTP_q3 + 1.5 * logTP_iqr), na.rm = TRUE)
  outlier_ratio <- logTP_outliers / nrow(df)

  # 数据分布特征记录
  distribution_info <- list(
    Skewness = skewness_logTP,
    Standard_Deviation = sd_logTP,
    Outlier_Ratio = outlier_ratio
  )

  # 步骤2：分析关系类型
  linear_model <- glm(FRic ~ logTP, data = df, family = gaussian())
  quadratic_model <- glm(FRic ~ logTP + I(logTP^2), data = df, family = gaussian())

  linear_aic <- AIC(linear_model)
  quadratic_aic <- AIC(quadratic_model)
  
  # AIC值差距不足10时，两个模型都进行关系判断
  if (abs(linear_aic - quadratic_aic) < 3) {
    linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
    linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
    quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
    quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]

    deviance_explained_linear <- (1 - linear_model$deviance / linear_model$null.deviance) * 100
    deviance_explained_quadratic <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

    if (linear_p < 0.1) {
      if (linear_coef > 0) {
        relationship_type <- "Positive Linear"
      } else {
        relationship_type <- "Negative Linear"
      }
      deviance_explained <- deviance_explained_linear
    } else if (quad_p < 0.1) {
      if (quad_coef < 0) {
        relationship_type <- "Unimodal"
      } else {
        relationship_type <- "Inverted Unimodal"
      }
      deviance_explained <- deviance_explained_quadratic
    } else {
      relationship_type <- "Non-significant"
      deviance_explained <- max(deviance_explained_linear, deviance_explained_quadratic)
    }
  } else {
    # 使用AIC值较低的模型进行关系判断
    if (quadratic_aic < linear_aic) {
      quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
      quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]
      deviance_explained <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

      if (quad_p < 0.1) {
        if (quad_coef < 0) {
          relationship_type <- "Unimodal"
        } else {
          relationship_type <- "Inverted Unimodal"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    } else {
      linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
      linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
      deviance_explained <- (1 - linear_model$deviance / linear_model$null.deviance) * 100

      if (linear_p < 0.1) {
        if (linear_coef > 0) {
          relationship_type <- "Positive Linear"
        } else {
          relationship_type <- "Negative Linear"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    }
  }

  # 返回结果
  return(list(
    Remove = Remove,
    Reason = Reason,
    Distribution_Info = distribution_info,
    Relationship_Type = relationship_type,
    Deviance_Explained = deviance_explained
  ))
}

# 应用到多个数据集
data_results <- lapply(split(data, data$Dataset), process_dataset)

# 提取结果为数据框
results_df <- data.frame(
  Dataset = names(data_results),
  Relationship_Type_FRic = sapply(data_results, function(x) x$Relationship_Type),
  Deviance_Explained_FRic = sapply(data_results, function(x) x$Deviance_Explained)
)

result <- data %>%
  group_by(Dataset) %>%
  summarise(
    Organism = first(Organism),
    Data = first(Data),
    Num = mean(Num, na.rm = TRUE),
    Area = mean(Area, na.rm = TRUE),
    Median_TP = median(TP, na.rm = TRUE),
    Median_AT = median(AT, na.rm = TRUE),
    Median_AP = median(AP, na.rm = TRUE),
    Median_Elevation = median(Elevation, na.rm = TRUE),
    Median_AL = median(AL, na.rm = TRUE),
    TP_Range = max(TP, na.rm = TRUE) - min(TP, na.rm = TRUE),
    AT_Range = max(AT, na.rm = TRUE) - min(AT, na.rm = TRUE),
    AP_Range = max(AP, na.rm = TRUE) - min(AP, na.rm = TRUE),
    Elevation_Range = max(Elevation, na.rm = TRUE) - min(Elevation, na.rm = TRUE),
    AL_Range = max(AL, na.rm = TRUE) - min(AL, na.rm = TRUE),
  ) %>%
  left_join(results_df, by = "Dataset") %>%
  distinct()


# 保留所有数据集并标注类型（不删除）
data <- data %>%left_join(result, by = "Dataset")

#write.csv(result, file = "D:/Desktop/Data/R/output/result_FRic.csv")
#write.csv(data, file = "D:/Desktop/Data/R/output/All_data_FRic.csv")
```

# Shape define FDis
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data=data[!is.na(data$FDis) & !is.na(data$logTP), ]


process_dataset <- function(df) {
  # 初始化默认值
  Remove <- FALSE
  Reason <- "Processed"

  # 步骤1：检查数据分布（仅报告，不剔除）
  skewness_logTP <- tryCatch({
    skewness(df$logTP, na.rm = TRUE)
  }, error = function(e) NA)

  sd_logTP <- sd(df$logTP, na.rm = TRUE)

  logTP_iqr <- IQR(df$logTP, na.rm = TRUE)
  logTP_q1 <- quantile(df$logTP, 0.25, na.rm = TRUE)
  logTP_q3 <- quantile(df$logTP, 0.75, na.rm = TRUE)
  logTP_outliers <- sum(df$logTP < (logTP_q1 - 1.5 * logTP_iqr) | 
                        df$logTP > (logTP_q3 + 1.5 * logTP_iqr), na.rm = TRUE)
  outlier_ratio <- logTP_outliers / nrow(df)

  # 数据分布特征记录
  distribution_info <- list(
    Skewness = skewness_logTP,
    Standard_Deviation = sd_logTP,
    Outlier_Ratio = outlier_ratio
  )

  # 步骤2：分析关系类型
  linear_model <- glm(FDis ~ logTP, data = df, family = gaussian())
  quadratic_model <- glm(FDis ~ logTP + I(logTP^2), data = df, family = gaussian())

  linear_aic <- AIC(linear_model)
  quadratic_aic <- AIC(quadratic_model)
  
  # AIC值差距不足10时，两个模型都进行关系判断
  if (abs(linear_aic - quadratic_aic) < 3) {
    linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
    linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
    quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
    quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]

    deviance_explained_linear <- (1 - linear_model$deviance / linear_model$null.deviance) * 100
    deviance_explained_quadratic <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

    if (linear_p < 0.1) {
      if (linear_coef > 0) {
        relationship_type <- "Positive Linear"
      } else {
        relationship_type <- "Negative Linear"
      }
      deviance_explained <- deviance_explained_linear
    } else if (quad_p < 0.1) {
      if (quad_coef < 0) {
        relationship_type <- "Unimodal"
      } else {
        relationship_type <- "Inverted Unimodal"
      }
      deviance_explained <- deviance_explained_quadratic
    } else {
      relationship_type <- "Non-significant"
      deviance_explained <- max(deviance_explained_linear, deviance_explained_quadratic)
    }
  } else {
    # 使用AIC值较低的模型进行关系判断
    if (quadratic_aic < linear_aic) {
      quad_p <- summary(quadratic_model)$coefficients["I(logTP^2)", "Pr(>|t|)"]
      quad_coef <- summary(quadratic_model)$coefficients["I(logTP^2)", "Estimate"]
      deviance_explained <- (1 - quadratic_model$deviance / quadratic_model$null.deviance) * 100

      if (quad_p < 0.1) {
        if (quad_coef < 0) {
          relationship_type <- "Unimodal"
        } else {
          relationship_type <- "Inverted Unimodal"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    } else {
      linear_p <- summary(linear_model)$coefficients["logTP", "Pr(>|t|)"]
      linear_coef <- summary(linear_model)$coefficients["logTP", "Estimate"]
      deviance_explained <- (1 - linear_model$deviance / linear_model$null.deviance) * 100

      if (linear_p < 0.1) {
        if (linear_coef > 0) {
          relationship_type <- "Positive Linear"
        } else {
          relationship_type <- "Negative Linear"
        }
      } else {
        relationship_type <- "Non-significant"
      }
    }
  }

  # 返回结果
  return(list(
    Remove = Remove,
    Reason = Reason,
    Distribution_Info = distribution_info,
    Relationship_Type = relationship_type,
    Deviance_Explained = deviance_explained
  ))
}

# 应用到多个数据集
data_results <- lapply(split(data, data$Dataset), process_dataset)

# 提取结果为数据框
results_df <- data.frame(
  Dataset = names(data_results),
  Relationship_Type_FDis = sapply(data_results, function(x) x$Relationship_Type),
  Deviance_Explained_FDis = sapply(data_results, function(x) x$Deviance_Explained)
)

result <- data %>%
  group_by(Dataset) %>%
  summarise(
    Organism = first(Organism),
    Data = first(Data),
    Num = mean(Num, na.rm = TRUE),
    Area = mean(Area, na.rm = TRUE),
    Median_TP = median(TP, na.rm = TRUE),
    Median_AT = median(AT, na.rm = TRUE),
    Median_AP = median(AP, na.rm = TRUE),
    Median_Elevation = median(Elevation, na.rm = TRUE),
    Median_AL = median(AL, na.rm = TRUE),
    TP_Range = max(TP, na.rm = TRUE) - min(TP, na.rm = TRUE),
    AT_Range = max(AT, na.rm = TRUE) - min(AT, na.rm = TRUE),
    AP_Range = max(AP, na.rm = TRUE) - min(AP, na.rm = TRUE),
    Elevation_Range = max(Elevation, na.rm = TRUE) - min(Elevation, na.rm = TRUE),
    AL_Range = max(AL, na.rm = TRUE) - min(AL, na.rm = TRUE),
  ) %>%
  left_join(results_df, by = "Dataset") %>%
  distinct()


# 保留所有数据集并标注类型（不删除）
data <- data %>%left_join(result, by = "Dataset")

#write.csv(result, file = "D:/Desktop/Data/R/output/result_FDis.csv")
#write.csv(data, file = "D:/Desktop/Data/R/output/All_data_FDis.csv")
```

# Relationship plot
```{r}

library(ggplot2)
library(patchwork)
library(ggforce)
library(ggExtra)
library(ggsignif)
library(multcompView)

result=read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")

result <- result %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18"))) %>%  # 过滤数据
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  )

dist_matrix <- dist(result[, c("Median_TP", "TP_Range")])  # 欧几里得距离矩阵
adonis_result <- adonis2(dist_matrix ~ Relationship_Type, data = result, permutations = 999)

# 提取 R² 和 p 值
r2_value <- round(adonis_result$R2[1], 3)
p_value <- signif(adonis_result$`Pr(>F)`[1], 3)


scatter_plot <-
  ggplot() +
  # 先绘制灰色点
  geom_point(data = result[result$Relationship_Type == "Non-significant", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type),
             size = 6, alpha = 0.9) +
  # 再绘制橙色点
  geom_point(data = result[result$Relationship_Type == "Unimodal", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type),
             size = 6, alpha = 0.9) +
  # 再绘制绿色点
  #geom_point(data = result[result$Relationship_Type == "Unimodal Upwards", ],
            # aes(x = Median_TP, y = TP_Range, color = Relationship_Type),
             #size = 6, alpha = 0.9) +
  # 再绘制蓝色点
  geom_point(data = result[result$Relationship_Type == "Negative Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type),
             size = 6, alpha = 0.9) +
  # 最后绘制红色点
  geom_point(data = result[result$Relationship_Type == "Positive Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type),
             size = 6, alpha = 0.9) +
  # 设置颜色手动映射
  scale_color_manual(
    name = "Relationship Shape",
    values = c(
      "Positive Linear" = "#0074b3", # 红色
      "Negative Linear" = "skyblue", # 蓝色
      "Unimodal Upwards" = "#f8984e", # 绿色
      "Unimodal" = "#db6968", # 橙色
      "Non-significant" = "gray" # 灰色
    )
  ) +
  labs(
    x = "Median Total Phosphorus",
    y = "Total Phosphorus Range"
  ) +
 theme_minimal() +
  theme(
    legend.position = c(0.634, 0.326),  # 将图例放置在左上角
    legend.justification = c(0, 1),   # 设置图例对齐左上角
    legend.background = element_rect(fill = "white", color = "black"),  # 图例背景为白色，带黑色边框
    plot.title = element_text(hjust = 0.5),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加外部边框
    axis.line = element_blank()    # 去掉轴线
  )

anova_result <- aov(Median_TP ~ Relationship_Type, data = result)
summary(aov(Median_TP ~ Relationship_Type, data = result))
tukey_result <- TukeyHSD(anova_result)

anova_result <- aov(TP_Range ~ Relationship_Type, data = result)
summary(aov(TP_Range ~ Relationship_Type, data = result))
tukey_result <- TukeyHSD(anova_result)

# 查看分组比较结果
print(tukey_result)

# 上方箱型图（水平排列）
significance_data_top <- data.frame(
  Relationship_Type = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  Median_TP = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

significance_data_right <- data.frame(
  Relationship_Type = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  TP_Range = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

# 上方箱型图（添加显著性标注）
boxplot_top <- ggplot(result, aes(y = Relationship_Type, x = Median_TP, fill = Relationship_Type)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    axis.title = element_blank(),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 



# 右侧箱型图（垂直展示）
boxplot_right <- ggplot(result, aes(y = TP_Range, x = Relationship_Type, fill = Relationship_Type)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    axis.title = element_blank(),
    axis.text = element_blank(),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 

# 统计检验结果标注图
annotation_plot <- ggplot() +
  theme_minimal() +  # 使用带有网格线的主题
  annotate(
    "text",
    x = 0.5, y = 0.5,
    label = paste0("PERMANOVA:\ndf = 3\nR² = ", round(r2_value, 5), "\nP = ", p_value),
    size = 3,  # 调小文字大小
    hjust = 0.5,
    vjust = 0.5,
    fontface = "bold" 
  ) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 增加边框
    axis.title = element_blank(),  # 去掉轴标题
    axis.text = element_blank(),  # 去掉轴文字
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.ticks = element_blank(),  # 去掉刻度线
    legend.position = "none"
  )

# 组合图表
final_plot <- (
  boxplot_top + annotation_plot +
  scatter_plot + boxplot_right
) +
  plot_layout(
    heights = c(1, 4),
    widths = c(4, 1),
    ncol = 2,
    nrow = 2
  )

# 显示图形
print(final_plot)

ggsave("D:/Desktop/Data/R/output/Relation_final.pdf",  width = 6, height = 6)
```

# Relationship plot FRic
```{r}
library(ggplot2)
library(patchwork)
library(ggforce)
library(ggExtra)
library(ggsignif)
library(multcompView)

result=read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")

result <- result %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18","BM11","AP05","AP06","AP07","AP08"))) %>%  # 过滤数据
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  )

dist_matrix <- dist(result[, c("Median_TP", "TP_Range")])  # 欧几里得距离矩阵
adonis_result <- adonis2(dist_matrix ~ Relationship_Type_FRic, data = result, permutations = 999)

# 提取 R² 和 p 值
r2_value <- round(adonis_result$R2[1], 3)
p_value <- signif(adonis_result$`Pr(>F)`[1], 3)


scatter_plot <-
  ggplot() +
  # 先绘制灰色点
  geom_point(data = result[result$Relationship_Type_FRic == "Non-significant", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FRic),
             size = 6, alpha = 0.9) +
  # 再绘制橙色点
  geom_point(data = result[result$Relationship_Type_FRic == "Unimodal", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FRic),
             size = 6, alpha = 0.9) +
  # 再绘制绿色点
  #geom_point(data = result[result$Relationship_Type_FRic == "Unimodal Upwards", ],
            # aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FRic),
             #size = 6, alpha = 0.9) +
  # 再绘制蓝色点
  geom_point(data = result[result$Relationship_Type_FRic == "Negative Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FRic),
             size = 6, alpha = 0.9) +
  # 最后绘制红色点
  geom_point(data = result[result$Relationship_Type_FRic == "Positive Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FRic),
             size = 6, alpha = 0.9) +
  # 设置颜色手动映射
  scale_color_manual(
    name = "Relationship Shape",
    values = c(
      "Positive Linear" = "#0074b3", # 红色
      "Negative Linear" = "skyblue", # 蓝色
      "Unimodal Upwards" = "#f8984e", # 绿色
      "Unimodal" = "#db6968", # 橙色
      "Non-significant" = "gray" # 灰色
    )
  ) +
  labs(
    x = "Median Total Phosphorus",
    y = "Total Phosphorus Range"
  ) +
 theme_minimal() +
  theme(
    legend.position = c(0.634, 0.326),  # 将图例放置在左上角
    legend.justification = c(0, 1),   # 设置图例对齐左上角
    legend.background = element_rect(fill = "white", color = "black"),  # 图例背景为白色，带黑色边框
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加外部边框
    axis.line = element_blank()    # 去掉轴线
  )

anova_result <- aov(Median_TP ~ Relationship_Type_FRic, data = result)
summary(aov(Median_TP ~ Relationship_Type_FRic, data = result))
tukey_result <- TukeyHSD(anova_result)

anova_result <- aov(TP_Range ~ Relationship_Type_FRic, data = result)
summary(aov(TP_Range ~ Relationship_Type_FRic, data = result))
tukey_result <- TukeyHSD(anova_result)

# 查看分组比较结果
print(tukey_result)

# 上方箱型图（水平排列）
significance_data_top <- data.frame(
  Relationship_Type_FRic = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  Median_TP = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

significance_data_right <- data.frame(
  Relationship_Type_FRic = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  TP_Range = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

# 上方箱型图（添加显著性标注）
boxplot_top <- ggplot(result, aes(y = Relationship_Type_FRic, x = Median_TP, fill = Relationship_Type_FRic)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 



# 右侧箱型图（垂直展示）
boxplot_right <- ggplot(result, aes(y = TP_Range, x = Relationship_Type_FRic, fill = Relationship_Type_FRic)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 

# 统计检验结果标注图
annotation_plot <- ggplot() +
  theme_minimal() +  # 使用带有网格线的主题
  annotate(
    "text",
    x = 0.5, y = 0.5,
    label = paste0("PERMANOVA:\ndf = 3\nR² = ", round(r2_value, 5), "\nP = ", p_value),
    size = 3,  # 调小文字大小
    hjust = 0.5,
    vjust = 0.5,
    fontface = "bold" 
  ) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 增加边框
    axis.title = element_blank(),  # 去掉轴标题
    axis.text = element_blank(),  # 去掉轴文字
    axis.ticks = element_blank(),  # 去掉刻度线
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    legend.position = "none"
  )

# 组合图表
final_plot <- (
  boxplot_top + annotation_plot +
  scatter_plot + boxplot_right
) +
  plot_layout(
    heights = c(1, 4),
    widths = c(4, 1),
    ncol = 2,
    nrow = 2
  )

# 显示图形
print(final_plot)


ggsave("D:/Desktop/Data/R/output/Relation_final_FRic.pdf",  width = 6, height = 6)
```

# Relationship plot Shannon
```{r}
library(ggplot2)
library(patchwork)
library(ggforce)
library(ggExtra)
library(ggsignif)
library(multcompView)

result=read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")

result <- result %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18","AP05","AP06","AP07","AP08","PP06","BM08","PP01"))) %>%  # 过滤数据
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  )

dist_matrix <- dist(result[, c("Median_TP", "TP_Range")])  # 欧几里得距离矩阵
adonis_result <- adonis2(dist_matrix ~ Relationship_Type_Shannon, data = result, permutations = 999)

# 提取 R² 和 p 值
r2_value <- round(adonis_result$R2[1], 3)
p_value <- signif(adonis_result$`Pr(>F)`[1], 3)


scatter_plot <-
  ggplot() +
  # 先绘制灰色点
  geom_point(data = result[result$Relationship_Type_Shannon == "Non-significant", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_Shannon),
             size = 6, alpha = 0.9) +
  # 再绘制橙色点
  geom_point(data = result[result$Relationship_Type_Shannon == "Unimodal", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_Shannon),
             size = 6, alpha = 0.9) +
  # 再绘制绿色点
  #geom_point(data = result[result$Relationship_Type_Shannon == "Unimodal Upwards", ],
            # aes(x = Median_TP, y = TP_Range, color = Relationship_Type_Shannon),
             #size = 6, alpha = 0.9) +
  # 再绘制蓝色点
  geom_point(data = result[result$Relationship_Type_Shannon == "Negative Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_Shannon),
             size = 6, alpha = 0.9) +
  # 最后绘制红色点
  geom_point(data = result[result$Relationship_Type_Shannon == "Positive Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_Shannon),
             size = 6, alpha = 0.9) +
  # 设置颜色手动映射
  scale_color_manual(
    name = "Relationship Shape",
    values = c(
      "Positive Linear" = "#0074b3", # 红色
      "Negative Linear" = "skyblue", # 蓝色
      "Unimodal Upwards" = "#f8984e", # 绿色
      "Unimodal" = "#db6968", # 橙色
      "Non-significant" = "gray" # 灰色
    )
  ) +
  labs(
    x = "Median Total Phosphorus",
    y = "Total Phosphorus Range"
  ) +
 theme_minimal() +
  theme(
    legend.position = c(0.634, 0.326),  # 将图例放置在左上角
    legend.justification = c(0, 1),   # 设置图例对齐左上角
    legend.background = element_rect(fill = "white", color = "black"),  # 图例背景为白色，带黑色边框
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加外部边框
    axis.line = element_blank()    # 去掉轴线
  )

anova_result <- aov(Median_TP ~ Relationship_Type_Shannon, data = result)
summary(aov(Median_TP ~ Relationship_Type_Shannon, data = result))
tukey_result <- TukeyHSD(anova_result)

anova_result <- aov(TP_Range ~ Relationship_Type_Shannon, data = result)
summary(aov(TP_Range ~ Relationship_Type_Shannon, data = result))
tukey_result <- TukeyHSD(anova_result)

# 查看分组比较结果
print(tukey_result)

# 上方箱型图（水平排列）
significance_data_top <- data.frame(
  Relationship_Type_Shannon = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  Median_TP = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

significance_data_right <- data.frame(
  Relationship_Type_Shannon = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  TP_Range = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

# 上方箱型图（添加显著性标注）
boxplot_top <- ggplot(result, aes(y = Relationship_Type_Shannon, x = Median_TP, fill = Relationship_Type_Shannon)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 



# 右侧箱型图（垂直展示）
boxplot_right <- ggplot(result, aes(y = TP_Range, x = Relationship_Type_Shannon, fill = Relationship_Type_Shannon)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 

# 统计检验结果标注图
annotation_plot <- ggplot() +
  theme_minimal() +  # 使用带有网格线的主题
  annotate(
    "text",
    x = 0.5, y = 0.5,
    label = paste0("PERMANOVA:\ndf = 3\nR² = ", round(r2_value, 5), "\nP = ", p_value),
    size = 3,  # 调小文字大小
    hjust = 0.5,
    vjust = 0.5,
    fontface = "bold" 
  ) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 增加边框
    axis.title = element_blank(),  # 去掉轴标题
    axis.text = element_blank(),  # 去掉轴文字
    axis.ticks = element_blank(),  # 去掉刻度线
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    legend.position = "none"
  )

# 组合图表
final_plot <- (
  boxplot_top + annotation_plot +
  scatter_plot + boxplot_right
) +
  plot_layout(
    heights = c(1, 4),
    widths = c(4, 1),
    ncol = 2,
    nrow = 2
  )

# 显示图形
print(final_plot)


ggsave("D:/Desktop/Data/R/output/Relation_final_Shannon.pdf",  width = 6, height = 6)
```


# Relationship plot FDis
```{r}
library(ggplot2)
library(patchwork)
library(ggforce)
library(ggExtra)
library(ggsignif)
library(multcompView)

result=read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")

result <- result %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18","PP07","AP05","AP06","AP07","AP08","PP06"))) %>%  # 过滤数据
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  )

dist_matrix <- dist(result[, c("Median_TP", "TP_Range")])  # 欧几里得距离矩阵
adonis_result <- adonis2(dist_matrix ~ Relationship_Type_FDis, data = result, permutations = 999)

# 提取 R² 和 p 值
r2_value <- round(adonis_result$R2[1], 3)
p_value <- signif(adonis_result$`Pr(>F)`[1], 3)


scatter_plot <-
  ggplot() +
  # 先绘制灰色点
  geom_point(data = result[result$Relationship_Type_FDis == "Non-significant", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FDis),
             size = 6, alpha = 0.9) +
  # 再绘制橙色点
  geom_point(data = result[result$Relationship_Type_FDis == "Unimodal", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FDis),
             size = 6, alpha = 0.9) +
  # 再绘制绿色点
  #geom_point(data = result[result$Relationship_Type_FDis == "Unimodal Upwards", ],
            # aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FDis),
             #size = 6, alpha = 0.9) +
  # 再绘制蓝色点
  geom_point(data = result[result$Relationship_Type_FDis == "Negative Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FDis),
             size = 6, alpha = 0.9) +
  # 最后绘制红色点
  geom_point(data = result[result$Relationship_Type_FDis == "Positive Linear", ],
             aes(x = Median_TP, y = TP_Range, color = Relationship_Type_FDis),
             size = 6, alpha = 0.9) +
  # 设置颜色手动映射
  scale_color_manual(
    name = "Relationship Shape",
    values = c(
      "Positive Linear" = "#0074b3", # 红色
      "Negative Linear" = "skyblue", # 蓝色
      "Unimodal Upwards" = "#f8984e", # 绿色
      "Unimodal" = "#db6968", # 橙色
      "Non-significant" = "gray" # 灰色
    )
  ) +
  labs(
    x = "Median Total Phosphorus",
    y = "Total Phosphorus Range"
  ) +
 theme_minimal() +
  theme(
    legend.position = c(0.634, 0.326),  # 将图例放置在左上角
    legend.justification = c(0, 1),   # 设置图例对齐左上角
    legend.background = element_rect(fill = "white", color = "black"),  # 图例背景为白色，带黑色边框
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加外部边框
    axis.line = element_blank()    # 去掉轴线
  )

anova_result <- aov(Median_TP ~ Relationship_Type_FDis, data = result)
summary(aov(Median_TP ~ Relationship_Type_FDis, data = result))
tukey_result <- TukeyHSD(anova_result)

anova_result <- aov(TP_Range ~ Relationship_Type_FDis, data = result)
summary(aov(TP_Range ~ Relationship_Type_FDis, data = result))
tukey_result <- TukeyHSD(anova_result)

# 查看分组比较结果
print(tukey_result)

# 上方箱型图（水平排列）
significance_data_top <- data.frame(
  Relationship_Type_FDis = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  Median_TP = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

significance_data_right <- data.frame(
  Relationship_Type_FDis = c("Unimodal", "Positive Linear", "Non-significant", "Negative Linear"),
  TP_Range = c(0.8, 0.6, 0.4, 0.2),  # 根据实际数值范围调整
  label = c("a", "b", "ab", "c")
)

# 上方箱型图（添加显著性标注）
boxplot_top <- ggplot(result, aes(y = Relationship_Type_FDis, x = Median_TP, fill = Relationship_Type_FDis)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 



# 右侧箱型图（垂直展示）
boxplot_right <- ggplot(result, aes(y = TP_Range, x = Relationship_Type_FDis, fill = Relationship_Type_FDis)) +
  geom_boxplot(outlier.shape = NA, width = 0.5, color = "black") +
  scale_fill_manual(values = c(
    "Positive Linear" = "#0074b3",
    "Negative Linear" = "skyblue",
    "Unimodal Upwards" = "#f8984e",
    "Unimodal" = "#db6968",
    "Non-significant" = "gray"
  )) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "none"
  ) 

# 统计检验结果标注图
annotation_plot <- ggplot() +
  theme_minimal() +  # 使用带有网格线的主题
  annotate(
    "text",
    x = 0.5, y = 0.5,
    label = paste0("PERMANOVA:\ndf = 3\nR² = ", round(r2_value, 5), "\nP = ", p_value),
    size = 3,  # 调小文字大小
    hjust = 0.5,
    vjust = 0.5,
    fontface = "bold" 
  ) +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 增加边框
    axis.title = element_blank(),  # 去掉轴标题
    axis.text = element_blank(),  # 去掉轴文字
    axis.ticks = element_blank(),  # 去掉刻度线
     panel.grid.major = element_blank(),  # 去除主网格线
    panel.grid.minor = element_blank(), 
    legend.position = "none"
  )

# 组合图表
final_plot <- (
  boxplot_top + annotation_plot +
  scatter_plot + boxplot_right
) +
  plot_layout(
    heights = c(1, 4),
    widths = c(4, 1),
    ncol = 2,
    nrow = 2
  )

# 显示图形
print(final_plot)


ggsave("D:/Desktop/Data/R/output/Relation_final_FDis.pdf",  width = 6, height = 6)
```


# Logistic test
```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(nnet)  # For multinomial logistic regression
library(cowplot)  # For combining plots

# Read the data
data <- read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")

# Data preprocessing for Relationship_Type
data_relationship_type <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD21", "BD19"))) %>%  # Filter out specific datasets for Relationship_Type
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  ) %>%
  subset(Relationship_Type != "Inverted Unimodal")  # Filter out "Inverted Unimodal" for Relationship_Type

data_relationship_type$Relationship_Type <- as.factor(data_relationship_type$Relationship_Type)
data_relationship_type$Relationship_Type <- relevel(data_relationship_type$Relationship_Type, ref = "Unimodal")

# Fit multinomial logistic regression model for Relationship_Type
model_relationship_type <- multinom(Relationship_Type ~ Median_TP + TP_Range, data = data_relationship_type)

# Data preprocessing for Relationship_Type_FRic
data_relationship_type_fric <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD21", "BD19", "BM11", "AP05", "AP06", "AP07", "AP08"))) %>%  # Filter out specific datasets for Relationship_Type_FRic
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  ) %>%
  subset(Relationship_Type_FRic != "Inverted Unimodal")  # Filter out "Inverted Unimodal" for Relationship_Type_FRic

data_relationship_type_fric$Relationship_Type_FRic <- as.factor(data_relationship_type_fric$Relationship_Type_FRic)
data_relationship_type_fric$Relationship_Type_FRic <- relevel(data_relationship_type_fric$Relationship_Type_FRic, ref = "Unimodal")

# Fit multinomial logistic regression model for Relationship_Type_FRic
model_relationship_type_fric <- multinom(Relationship_Type_FRic ~ Median_TP + TP_Range, data = data_relationship_type_fric)

# Prepare forest plot data function
prepare_forest_data <- function(model, variable_name) {
  coefficients <- summary(model)$coefficients
  std_errors <- summary(model)$standard.errors
  col_idx <- grep(variable_name, colnames(coefficients))
  if (length(col_idx) == 0) stop(paste("Variable", variable_name, "not found in model coefficients."))
  
  coefs <- coefficients[, col_idx, drop = TRUE]
  ses <- std_errors[, col_idx, drop = TRUE]
  p_values <- 2 * (1 - pnorm(abs(coefs / ses)))
  ci_lower <- coefs - 1.96 * ses
  ci_upper <- coefs + 1.96 * ses
  stars <- ifelse(p_values < 0.001, "***",
           ifelse(p_values < 0.01, "**",
           ifelse(p_values < 0.1, "*", "")))
  
  data.frame(
    Category = rownames(coefficients),
    Coefficient = coefs,
    CI_Lower = ci_lower,
    CI_Upper = ci_upper,
    P_Value = p_values,
    Stars = stars,
    Variable = variable_name
  )
}

# Add color info to forest data
add_color_info <- function(data, color_value) {
  data$Color <- color_value
  return(data)
}

# Prepare forest plot data for both models
forest_data_relationship_type <- prepare_forest_data(model_relationship_type, "Median_TP")
forest_data_relationship_type_fric <- prepare_forest_data(model_relationship_type_fric, "Median_TP")

# Add color information to both data sets (blue for Relationship_Type and red for Relationship_Type_FRic)
forest_data_relationship_type <- add_color_info(forest_data_relationship_type, "#0074b3")  # Blue color for Relationship_Type
forest_data_relationship_type_fric <- add_color_info(forest_data_relationship_type_fric, "#FF6347")  # Red color for Relationship_Type_FRic

# Combine both data sets into one for plotting
forest_data_combined <- rbind(forest_data_relationship_type, forest_data_relationship_type_fric)
forest_data_combined$Type <- rep(c("Relationship_Type", "Relationship_Type_FRic"), 
                                 times = c(nrow(forest_data_relationship_type), nrow(forest_data_relationship_type_fric)))

# Plot for combined forest data (vertical)
combined_forest_plot <- ggplot(forest_data_combined, aes(x = Coefficient, y = Category, color = Type)) +
  geom_point(size = 3) +
  geom_errorbar(aes(xmin = CI_Lower, xmax = CI_Upper), height = 0, size = 1) +  # Adjust error bars for horizontal orientation
  annotate("text", y = forest_data_combined$Category, 
           x = forest_data_combined$CI_Upper + 0.1, 
           label = forest_data_combined$Stars, size = 5, color = "black") +
  geom_vline(xintercept = 0, color = "black", size = 0.8, linetype = "dashed") +  # Change to vertical line for x-axis
  scale_color_manual(values = c("Relationship_Type" = "#0074b3", "Relationship_Type_FRic" = "#FF6347")) +
  scale_x_continuous(limits = c(-3.1, 3.1)) +  # Adjust x-axis limits
  labs(
    title = "Forest Plot of Coefficients for Relationship_Type and Relationship_Type_FRic",
    x = "Coefficient (95% CI)",  # Update x-axis label
    y = "Variable"  # Update y-axis label
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.5),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 10),
    axis.text.x = element_text(size = 10),
    axis.text.y = element_text(size = 10, angle = 0, hjust = 1),  # Rotate text on y-axis if necessary
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    axis.line.x = element_line(color = "black", size = 0.8),
    axis.line.y = element_line(color = "black", size = 0.8)
  )

# Print the modified plot
print(combined_forest_plot)



```


# Logistic
```{r}

library(cowplot)
library(nnet)

data=read.csv(file = "D:/Desktop/Data/R/output/result_all.csv")

data <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD21", "BD19"))) %>%  # 过滤数据
  mutate(
    Median_TP = log(Median_TP), 
    TP_Range = log(TP_Range)
  )

data <- subset(data, Relationship_Type != "Inverted Unimodal") 
data$Relationship_Type <- as.factor(data$Relationship_Type)

# 创建自变量和因变量
features <- c("Median_TP", "TP_Range")
data <- data[, c(features, "Relationship_Type")]
#data$Relationship_Type <- relevel(data$Relationship_Type, ref = "Non-significant")
data$Relationship_Type <- relevel(data$Relationship_Type, ref = "Unimodal")
# 拟合多分类 Logistic 回归模型
model <- multinom(Relationship_Type ~ Median_TP + TP_Range, data = data)

# 输出模型结果
summary(model)

coefficients <- summary(model)$coefficients
std_errors <- summary(model)$standard.errors

# 准备森林图数据
prepare_forest_data <- function(model, variable_name) {
  coefficients <- summary(model)$coefficients
  std_errors <- summary(model)$standard.errors
  col_idx <- grep(variable_name, colnames(coefficients))
  if (length(col_idx) == 0) stop(paste("Variable", variable_name, "not found in model coefficients."))
  
  coefs <- coefficients[, col_idx, drop = TRUE]
  ses <- std_errors[, col_idx, drop = TRUE]
  p_values <- 2 * (1 - pnorm(abs(coefs / ses)))
  ci_lower <- coefs - 1.96 * ses
  ci_upper <- coefs + 1.96 * ses
  stars <- ifelse(p_values < 0.001, "***",
           ifelse(p_values < 0.01, "**",
           ifelse(p_values < 0.1, "*", "")))
  
  data.frame(
    Category = rownames(coefficients),
    Coefficient = coefs,
    CI_Lower = ci_lower,
    CI_Upper = ci_upper,
    P_Value = p_values,
    Stars = stars,
    Variable = variable_name
  )
}

# 添加颜色信息函数
add_color_info <- function(data) {
  data$Color <- ifelse(data$CI_Lower < 0 & data$CI_Upper > 0, "grey", "#0074b3")
  return(data)
}

# 生成森林图数据
forest_data_tp <- prepare_forest_data(model, "Median_TP")
forest_data_tp_range <- prepare_forest_data(model, "TP_Range")

# 为数据添加颜色信息
forest_data_tp <- add_color_info(forest_data_tp)
forest_data_tp_range <- add_color_info(forest_data_tp_range)


plot_tp <- ggplot(forest_data_tp, aes(y = Coefficient, x = Category)) +
  geom_point(size = 3, aes(color = Color)) +
  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper, color = Color), width = 0, size = 1) +
  # 动态添加显著性星号位置
  annotate("text", x = forest_data_tp$Category, 
           y = forest_data_tp$CI_Upper + 0.1, 
           label = forest_data_tp$Stars, size = 5, color = "black") +
  geom_hline(yintercept = 0, color = "black", size = 0.8, linetype = "dashed") +
  scale_color_identity() +
  scale_y_continuous(limits = c(-3.1, 3.1)) +
  labs(
    title = "Total Phosphorus Level",
    y = "Coefficient (95% CI)",
    x = "Baseline: Non-significant"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.1),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 10),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1), # 倾斜45度
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    axis.line.x = element_line(color = "black", size = 0.8),
    axis.line.y = element_line(color = "black", size = 0.8)
  )


plot_tp_range <- ggplot(forest_data_tp_range, aes(y = Coefficient, x = Category)) +
  geom_point(size = 3, aes(color = Color)) +
  geom_errorbar(aes(ymin = CI_Lower, ymax = CI_Upper, color = Color), width = 0, size = 1) +
  # 动态添加显著性星号位置
  annotate("text", x = forest_data_tp_range$Category, 
           y = forest_data_tp_range$CI_Upper + 0.1, 
           label = forest_data_tp_range$Stars, size = 5, color = "black") +
  geom_hline(yintercept = 0, color = "black", size = 0.8, linetype = "dashed") +
  scale_color_identity() +
  scale_y_continuous(limits = c(-3.3, 3.3)) +
  labs(
    title = "Total Phosphorus Range",
    y = "Coefficient (95% CI)",
    x = "Baseline: Non-significant"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.1),
    axis.title.x = element_text(size = 12),
    axis.title.y = element_text(size = 10),
    axis.text.x = element_text(size = 10, angle = 45, hjust = 1), # 倾斜45度
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    axis.line.x = element_line(color = "black", size = 0.8),
    axis.line.y = element_line(color = "black", size = 0.8)
  )


combined_plot <- plot_grid(plot_tp, plot_tp_range, ncol = 2, align = "v") # 水平对齐
print(combined_plot)

#ggsave("D:/Desktop/Data/R/output/forest_nosig.pdf", combined_plot, width = 6, height = 3)




```

# Scatter plot (old)
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
library(ggplot2)
data$Relationship_Type <- gsub("Inverted Unimodal", "U-shape", data$Relationship_Type)
data$Dataset <- as.factor(data$Dataset)
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))

custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)

Sca_Richness =
  ggplot(data, aes(x = logTP, y = Richness, linetype = Data, color = Relationship_Type)) + 
  # 针对线性类别单独拟合
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Positive Linear", "Negative Linear")),
    aes(group = Dataset), 
    method = "lm",  # 线性拟合
    formula = y ~ x, 
    fill = "#a3d393", alpha = 0.3
  ) +
  
  # 针对二次拟合的类别
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Unimodal", "U-shape")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "#fdc58f", alpha = 0.3
  ) +
  
  geom_smooth(
    data = subset(data, Relationship_Type %in% c( "Non-significant")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "white", alpha = 0.3,
     se = FALSE 
  ) +
  labs(x = "Productivity (Total Phosphorus)",
       y = "Richness") +
  theme_minimal() +  # 使用简约主题
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加黑色边框
    panel.grid.major = element_blank(),  # 去掉主要网格线
    panel.grid.minor = element_blank(),  # 去掉次要网格线
    legend.key.size = unit(0.7, "cm"),  # 调整图例框大小
    legend.text = element_text(size = 10),  # 调整图例文字大小
    legend.title = element_text(size = 14),  # 调整图例标题大小
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16), # X 轴标题大小
    axis.text.x = element_text(size = 14),  # X 轴标签大小
    axis.text.y = element_text(size = 14),   # Y 轴标签大小
    strip.text = element_text(size = 14)     # 调整子图标题（Organism）的字体大小
  ) +
  facet_wrap(~ Organism) +  # 将图按照 Organism 分成六个类别
  guides(color = guide_legend(title = "Relationship Type"), linetype = guide_legend(title = "Waterbody Type")) +  # 自定义图例标题
  scale_x_continuous( expand = c(0, 0.5)) +# 去掉 X 轴的空隙
  scale_y_continuous(limits = c(0, 70), expand = c(0, 0)) +  # 去掉 Y 轴的空隙
  scale_color_manual(
    values = c(
      "U-shape" = "#f8984e",  # 自定义颜色
      "Negative Linear" = "skyblue",
      "Non-significant" = "gray",
      "Positive Linear" = "#0074b3",
      "Unimodal" = "#db6968"
    )
  )

plot(Sca_Richness)

#ggsave("D:/Desktop/Data/R/output/Sca_Richness.pdf", plot = Sca_Richness, device = "pdf", width = 10, height = 6)


data=read.csv("D:/Desktop/Data/R/output/All_data_FRic.csv")
data$Relationship_Type <- gsub("Inverted Unimodal", "U-shape", data$Relationship_Type)
library(ggplot2)

data$Dataset <- as.factor(data$Dataset)
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))

custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)

Sca_FRic =
  ggplot(data, aes(x = logTP, y = FRic, linetype = Data, color = Relationship_Type)) + 
  # 针对线性类别单独拟合
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Positive Linear", "Negative Linear")),
    aes(group = Dataset), 
    method = "lm",  # 线性拟合
    formula = y ~ x, 
    fill = "#a3d393", alpha = 0.3
  ) +
  
  # 针对二次拟合的类别
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Unimodal", "U-shape")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "#fdc58f", alpha = 0.3
  ) +
  
  geom_smooth(
    data = subset(data, Relationship_Type %in% c( "Non-significant")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "white", alpha = 0.3,
     se = FALSE 
  ) +
  labs(x = "Productivity (Total Phosphorus)",
       y = "FRic") +
  theme_minimal() +  # 使用简约主题
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加黑色边框
    panel.grid.major = element_blank(),  # 去掉主要网格线
    panel.grid.minor = element_blank(),  # 去掉次要网格线
    legend.key.size = unit(0.7, "cm"),  # 调整图例框大小
    legend.text = element_text(size = 10),  # 调整图例文字大小
    legend.title = element_text(size = 14),  # 调整图例标题大小
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16), # X 轴标题大小
    axis.text.x = element_text(size = 14),  # X 轴标签大小
    axis.text.y = element_text(size = 14),   # Y 轴标签大小
    strip.text = element_text(size = 14)     # 调整子图标题（Organism）的字体大小
  ) +
  facet_wrap(~ Organism) +  # 将图按照 Organism 分成六个类别
  guides(color = guide_legend(title = "Relationship Type"), linetype = guide_legend(title = "Waterbody Type")) +  # 自定义图例标题
  scale_x_continuous( expand = c(0, 0.5)) +# 去掉 X 轴的空隙
  scale_y_continuous(limits = c(0, 70), expand = c(0, 0)) +  # 去掉 Y 轴的空隙
  scale_color_manual(
    values = c(
      "U-shape" = "#f8984e",  # 自定义颜色
      "Negative Linear" = "skyblue",
      "Non-significant" = "gray",
      "Positive Linear" = "#0074b3",
      "Unimodal" = "#db6968"
    )
  )

plot(Sca_FRic)

#ggsave("D:/Desktop/Data/R/output/Sca_FRic.pdf", plot = Sca_FRic, device = "pdf", width = 10, height = 6)

```

# Scatter plot (Shannon)
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data_Shannon.csv")
library(ggplot2)

data <- data %>%
  filter(!Dataset %in% c("PP06", "AP06", "AP05","AP07", "AP08"))

data$Dataset <- as.factor(data$Dataset)
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))

custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)

Sca_Shannon =
  ggplot(data, aes(x = logTP, y = Shannon, linetype = Data, color = Relationship_Type)) + 
  # 针对线性类别单独拟合
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Positive Linear", "Negative Linear")),
    aes(group = Dataset), 
    method = "lm",  # 线性拟合
    formula = y ~ x, 
    fill = "#a3d393", alpha = 0.3
  ) +
  
  # 针对二次拟合的类别
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Unimodal", "Inverted Unimodal")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "#fdc58f", alpha = 0.3
  ) +
  
  geom_smooth(
    data = subset(data, Relationship_Type %in% c( "Non-significant")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "white", alpha = 0.3,
     se = FALSE 
  ) +
  labs(x = "Productivity (Total Phosphorus)",
       y = "Shannon") +
  theme_minimal() +  # 使用简约主题
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加黑色边框
    panel.grid.major = element_blank(),  # 去掉主要网格线
    panel.grid.minor = element_blank(),  # 去掉次要网格线
    legend.key.size = unit(0.7, "cm"),  # 调整图例框大小
    legend.text = element_text(size = 10),  # 调整图例文字大小
    legend.title = element_text(size = 14),  # 调整图例标题大小
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16), # X 轴标题大小
    axis.text.x = element_text(size = 14),  # X 轴标签大小
    axis.text.y = element_text(size = 14),   # Y 轴标签大小
    strip.text = element_text(size = 14)     # 调整子图标题（Organism）的字体大小
  ) +
  facet_wrap(~ Organism) +  # 将图按照 Organism 分成六个类别
  guides(color = guide_legend(title = "Relationship Type"), linetype = guide_legend(title = "Waterbody Type")) +  # 自定义图例标题
  scale_x_continuous( expand = c(0, 0.5)) +# 去掉 X 轴的空隙
  scale_y_continuous(limits = c(0, 4.5), expand = c(0, 0)) +  # 去掉 Y 轴的空隙
  scale_color_manual(
    values = c(
      "Inverted Unimodal" = "#f8984e",  # 自定义颜色
      "Negative Linear" = "skyblue",
      "Non-significant" = "gray",
      "Positive Linear" = "#0074b3",
      "Unimodal" = "#db6968"
    )
  )

plot(Sca_Shannon)

#ggsave("D:/Desktop/Data/R/output/Sca_Shannon.pdf", plot = Sca_Shannon, device = "pdf", width = 10, height = 6)


```

# Scatter plot (FDis)
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data_FDis.csv")
library(ggplot2)

data <- data %>%
  filter(!Dataset == "PP06")

data$Dataset <- as.factor(data$Dataset)
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))

custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)

Sca_FDis =
  ggplot(data, aes(x = logTP, y = FDis, linetype = Data, color = Relationship_Type)) + 
  # 针对线性类别单独拟合
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Positive Linear", "Negative Linear")),
    aes(group = Dataset), 
    method = "lm",  # 线性拟合
    formula = y ~ x, 
    fill = "#a3d393", alpha = 0.3
  ) +
  
  # 针对二次拟合的类别
  geom_smooth(
    data = subset(data, Relationship_Type %in% c("Unimodal", "Inverted Unimodal")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "#fdc58f", alpha = 0.3
  ) +
  
  geom_smooth(
    data = subset(data, Relationship_Type %in% c( "Non-significant")),
    aes(group = Dataset), 
    method = "lm",  # 二次拟合
    formula = y ~ poly(x, 2), 
    fill = "white", alpha = 0.3,
     se = FALSE 
  ) +
  labs(x = "Productivity (Total Phosphorus)",
       y = "FDis") +
  theme_minimal() +  # 使用简约主题
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 添加黑色边框
    panel.grid.major = element_blank(),  # 去掉主要网格线
    panel.grid.minor = element_blank(),  # 去掉次要网格线
    legend.key.size = unit(0.7, "cm"),  # 调整图例框大小
    legend.text = element_text(size = 10),  # 调整图例文字大小
    legend.title = element_text(size = 14),  # 调整图例标题大小
    axis.title.y = element_text(size = 16),
    axis.title.x = element_text(size = 16), # X 轴标题大小
    axis.text.x = element_text(size = 14),  # X 轴标签大小
    axis.text.y = element_text(size = 14),   # Y 轴标签大小
    strip.text = element_text(size = 14)     # 调整子图标题（Organism）的字体大小
  ) +
  facet_wrap(~ Organism) +  # 将图按照 Organism 分成六个类别
  guides(color = guide_legend(title = "Relationship Type"), linetype = guide_legend(title = "Waterbody Type")) +  # 自定义图例标题
  scale_x_continuous( expand = c(0, 0.5)) +# 去掉 X 轴的空隙
  scale_y_continuous(limits = c(0, 8), expand = c(0, 0)) +  # 去掉 Y 轴的空隙
  scale_color_manual(
    values = c(
      "Inverted Unimodal" = "#f8984e",  # 自定义颜色
      "Negative Linear" = "skyblue",
      "Non-significant" = "gray",
      "Positive Linear" = "#0074b3",
      "Unimodal" = "#db6968"
    )
  )

plot(Sca_FDis)

#ggsave("D:/Desktop/Data/R/output/Sca_FDis.pdf", plot = Sca_FDis, device = "pdf", width = 10, height = 6)


```


# Scatter together plot
```{r}
library(ggplot2)
library(dplyr)
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")

data <- data %>% mutate(Dataset = as.factor(Dataset))

ggplot(data, aes(x = logTP, y = Richness)) +
  geom_point(aes(color = Relationship_Type), alpha = 0.6) +  
  scale_color_manual(
    values = c("Non-significant" = "#bdc3d2",
               "Positive Linear" = "#a3d393",
               "Negative Linear" = "#a3d393",
               "Unimodal" = "#fdc58f",
               "Inverted Unimodal" = "#fdc58f"),
    guide = "none"
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Positive Linear"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ x,
    color = "#0074b3",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Negative Linear"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ x,
    color = "skyblue",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Inverted Unimodal"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ poly(x, 2),
    color = "#f8984e",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Unimodal"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ poly(x, 2),
    color = "#db6968",
    se = FALSE
  ) +
  facet_wrap(
    ~ Dataset,  # 根据 Dataset 分面
    ncol = 10,  # 每行子图数量
    scales = "free"  # 允许每个子图的 X 轴和 Y 轴自由缩放
  ) +
  labs(
    x = "Total Phosphorus (log)",
    y = "Richness"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 5),
    axis.title = element_text(size = 16),
    strip.text = element_text(size = 8),  # Dataset 标签样式
    strip.background = element_rect(fill = "lightgray", color = "black")  # 标签背景为浅灰色，边框为黑色
  ) +
  geom_text(
    aes(label = ifelse(
      Relationship_Type == "Non-significant", 
      paste0("n=", Num, "\nNS"),
      paste0("n=", Num, "\nD=", round(Deviance_Explained, 1), "%")
    )),
    x = Inf, y = Inf,
    hjust = 1.1, vjust = 1.1,
    size = 3
  ) +
  coord_cartesian(ylim = c(0, NA)) # 设置 Y 轴最小值始终为 0

#ggsave("D:/Desktop/Data/R/output/Relation_TPlog.pdf", device = "pdf", width = 12, height = 12)


ggplot(data, aes(x = TP, y = Richness)) +
  geom_point(aes(color = Relationship_Type), alpha = 0.6) +  
  scale_color_manual(
    values = c("Non-significant" = "#bdc3d2",
               "Positive Linear" = "#a3d393",
               "Negative Linear" = "#a3d393",
               "Unimodal" = "#fdc58f",
               "Inverted Unimodal" = "#fdc58f"),
    guide = "none"
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Positive Linear"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ x,
    color = "#0074b3",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Negative Linear"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ x,
    color = "skyblue",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Inverted Unimodal"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ poly(x, 2),
    color = "#f8984e",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Unimodal"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ poly(x, 2),
    color = "#db6968",
    se = FALSE
  ) +
  facet_wrap(
    ~ Dataset,  # 根据 Dataset 分面
    ncol = 10,  # 每行子图数量
    scales = "free"  # 允许每个子图的 X 轴和 Y 轴自由缩放
  ) +
  labs(
    x = "Total Phosphorus",
    y = "Richness"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 5),
    axis.title = element_text(size = 16),
    strip.text = element_text(size = 8),  # Dataset 标签样式
    strip.background = element_rect(fill = "lightgray", color = "black")  # 标签背景为浅灰色，边框为黑色
  ) +
  geom_text(
    aes(label = ifelse(
      Relationship_Type == "Non-significant", 
      paste0("n=", Num, "\nNS"),
      paste0("n=", Num, "\nD=", round(Deviance_Explained, 1), "%")
    )),
    x = Inf, y = Inf,
    hjust = 1.1, vjust = 1.1,
    size = 3
  ) +
  coord_cartesian(ylim = c(0, NA)) # 设置 Y 轴最小值始终为 0

#ggsave("D:/Desktop/Data/R/output/Relation_TP.pdf", device = "pdf", width = 12, height = 12)
```

# Scatter together plot FRic
```{r}
library(ggplot2)
library(dplyr)
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")

data <- data %>% mutate(Dataset = as.factor(Dataset))

ggplot(data, aes(x = logTP, y = FRic)) +
  geom_point(aes(color = Relationship_Type), alpha = 0.6) +  
  scale_color_manual(
    values = c("Non-significant" = "#bdc3d2",
               "Positive Linear" = "#a3d393",
               "Negative Linear" = "#a3d393",
               "Unimodal" = "#fdc58f",
               "Inverted Unimodal" = "#fdc58f"),
    guide = "none"
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Positive Linear"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ x,
    color = "#0074b3",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Negative Linear"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ x,
    color = "skyblue",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Inverted Unimodal"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ poly(x, 2),
    color = "#f8984e",
    se = FALSE
  ) +
  geom_smooth(
    data = data %>% filter(Relationship_Type == "Unimodal"),
    aes(group = Dataset),
    method = "glm",
    formula = y ~ poly(x, 2),
    color = "#db6968",
    se = FALSE
  ) +
  facet_wrap(
    ~ Dataset,  # 根据 Dataset 分面
    ncol = 10,  # 每行子图数量
    scales = "free"  # 允许每个子图的 X 轴和 Y 轴自由缩放
  ) +
  labs(
    x = "Total Phosphorus (log)",
    y = "FRic"
  ) +
  theme_minimal() +
  theme(
    panel.border = element_rect(color = "black", fill = NA, size = 0.5),
    panel.spacing = unit(0.5, "lines"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text = element_text(size = 5),
    axis.title = element_text(size = 16),
    strip.text = element_text(size = 8),  # Dataset 标签样式
    strip.background = element_rect(fill = "lightgray", color = "black")  # 标签背景为浅灰色，边框为黑色
  ) +
  geom_text(
    aes(label = ifelse(
      Relationship_Type == "Non-significant", 
      paste0("n=", Num, "\nNS"),
      paste0("n=", Num, "\nD=", round(Deviance_Explained, 1), "%")
    )),
    x = Inf, y = Inf,
    hjust = 1.1, vjust = 1.1,
    size = 3
  ) +
  coord_cartesian(ylim = c(0, NA)) # 设置 Y 轴最小值始终为 0

#ggsave("D:/Desktop/Data/R/output/Relation_TPlog_FRic.pdf", device = "pdf", width = 12, height = 12)
```

# Box plot
```{r}

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  group_by(Dataset) %>%
  mutate(
    Eutrophic_Group = case_when(
      TP >= quantile(TP, 0.75) ~ "High",
      TP <= quantile(TP, 0.25) ~ "Low",
      TRUE ~ "Medium"
    )
  ) %>%
  filter(Eutrophic_Group != "Medium")

data$Eutrophic_Group <- factor(data$Eutrophic_Group, levels = c("Low", "High"))

data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))


custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)


Box_Richness <-
  ggplot(data, aes(x = Dataset, y = Richness, fill = Eutrophic_Group)) +
  geom_boxplot(color = "black") +  
  labs(x = "", y = "Richness") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 保留外部边框
    panel.grid = element_blank(),    # 去掉所有内部网格线
    strip.text = element_text(size = 20, hjust = 0)  # 调整分面标签字体大小并对齐左侧
  ) +
  scale_fill_manual(values = c("Low" = "#99cbeb", "High" = "#547ac0")) + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 18),
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 16),
    strip.text = element_text(size = 26, hjust = 0)  # 标题左对齐
  ) +
  stat_compare_means(
    aes(group = Eutrophic_Group),
    method = "wilcox.test", 
    label = "p.signif", 
    size = 6,
    vjust = 1.5,
    symnum.args = list(
      cutpoints = c(0, 0.05, 1),  # 定义p值的分段
      symbols = c("*", "")       # 显著性符号：显著为“*”，非显著为空
    )
  ) +
  facet_wrap(~Organism, scales = "free", ncol = 3, nrow = 2)


plot(Box_Richness)

#ggsave("D:/Desktop/Data/R/output/Box_Richness.pdf", plot = Box_Richness, device = "pdf", width = 14, height =7)


results <- data %>%
  group_by(Dataset) %>%
  summarise(
    Median_Low = median(Richness[Eutrophic_Group == "Low"], na.rm = TRUE),
    Median_High = median(Richness[Eutrophic_Group == "High"], na.rm = TRUE),
    P_Value = ifelse(
      length(Richness[Eutrophic_Group == "Low"]) > 0 & length(Richness[Eutrophic_Group == "High"]) > 0,
      wilcox.test(
        Richness[Eutrophic_Group == "Low"],
        Richness[Eutrophic_Group == "High"]
      )$p.value,
      NA
    )
  ) %>%
  mutate(
    Difference = case_when(
      Median_High > Median_Low ~ "Higher",
      Median_High < Median_Low ~ "Lower",
      TRUE ~ "Equal"
    ),
    Significance = case_when(
      P_Value < 0.05 ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )


datasets_to_remove <- data %>%
  group_by(Dataset) %>%
  summarise(all_na = all(is.na(FRic))) %>%
  filter(all_na) %>%
  pull(Dataset)

# 过滤掉这些 Dataset 所对应的所有行
data_filtered <- data %>%
  filter(!Dataset %in% datasets_to_remove)




Box_FRic <-
  ggplot(data_filtered, aes(x = Dataset, y = FRic, fill = Eutrophic_Group)) +
  geom_boxplot(color = "black") +  
  labs(x = "", y = "FRic") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 保留外部边框
    panel.grid = element_blank(),    # 去掉所有内部网格线
    strip.text = element_text(size = 20)  # 调整分面标签字体大小
  ) +
  scale_fill_manual(values = c("Low" = "#fce4d4", "High" = "#ffc48a")) + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 18),
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 16),
    strip.text = element_text(size = 26)  # 调整Organism标签字体大小
  ) +
  stat_compare_means(
    aes(group = Eutrophic_Group),
    method = "wilcox.test", 
    label = "p.signif", 
    size = 6,
    vjust = 1.5,
    symnum.args = list(
      cutpoints = c(0, 0.05, 1),  # 定义p值的分段
      symbols = c("*", "")       # 显著性符号：显著为“*”，非显著为空
    )
  ) +
  facet_wrap(~Organism, scales = "free", ncol = 3, nrow = 2)

plot(Box_FRic)

#ggsave("D:/Desktop/Data/R/output/Box_FRic.pdf", plot = Box_FRic, device = "pdf", width = 14, height =7)


results <- data_filtered %>%
  group_by(Dataset) %>%
  summarise(
    Median_Low = median(FRic[Eutrophic_Group == "Low"], na.rm = TRUE),
    Median_High = median(FRic[Eutrophic_Group == "High"], na.rm = TRUE),
    P_Value = ifelse(
      length(FRic[Eutrophic_Group == "Low"]) > 0 & length(FRic[Eutrophic_Group == "High"]) > 0,
      wilcox.test(
        FRic[Eutrophic_Group == "Low"],
        FRic[Eutrophic_Group == "High"]
      )$p.value,
      NA
    )
  ) %>%
  mutate(
    Difference = case_when(
      Median_High > Median_Low ~ "Higher",
      Median_High < Median_Low ~ "Lower",
      TRUE ~ "Equal"
    ),
    Significance = case_when(
      P_Value < 0.05 ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )

```


# Box plot Shannon
```{r}

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  group_by(Dataset) %>%
  mutate(
    Eutrophic_Group = case_when(
      TP >= quantile(TP, 0.75) ~ "High",
      TP <= quantile(TP, 0.25) ~ "Low",
      TRUE ~ "Medium"
    )
  ) %>%
  filter(Eutrophic_Group != "Medium")

data$Eutrophic_Group <- factor(data$Eutrophic_Group, levels = c("Low", "High"))

data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))


custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)



datasets_to_remove <- data %>%
  group_by(Dataset) %>%
  summarise(all_na = all(is.na(Shannon))) %>%
  filter(all_na) %>%
  pull(Dataset)

# 过滤掉这些 Dataset 所对应的所有行
data_filtered <- data %>%
  filter(!Dataset %in% datasets_to_remove)

data_filtered <- data %>%
  filter(!Dataset == "PP06")


Box_Shannon <-
  ggplot(data_filtered, aes(x = Dataset, y = Shannon, fill = Eutrophic_Group)) +
  geom_boxplot(color = "black") +  
  labs(x = "", y = "Shannon") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 保留外部边框
    panel.grid = element_blank(),    # 去掉所有内部网格线
    strip.text = element_text(size = 20)  # 调整分面标签字体大小
  ) +
  scale_fill_manual(values = c("Low" = "#99cbeb", "High" = "#547ac0")) + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 18),
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 16),
    strip.text = element_text(size = 26)  # 调整Organism标签字体大小
  ) +
  stat_compare_means(
    aes(group = Eutrophic_Group),
    method = "wilcox.test", 
    label = "p.signif", 
    size = 6,
    vjust = 1.5,
    symnum.args = list(
      cutpoints = c(0, 0.05, 1),  # 定义p值的分段
      symbols = c("*", "")       # 显著性符号：显著为“*”，非显著为空
    )
  ) +
  facet_wrap(~Organism, scales = "free", ncol = 3, nrow = 2)

plot(Box_Shannon)

#ggsave("D:/Desktop/Data/R/output/Box_Shannon.pdf", plot = Box_Shannon, device = "pdf", width = 14, height =7)


results <- data_filtered %>%
  group_by(Dataset) %>%
  summarise(
    Median_Low = median(Shannon[Eutrophic_Group == "Low"], na.rm = TRUE),
    Median_High = median(Shannon[Eutrophic_Group == "High"], na.rm = TRUE),
    P_Value = ifelse(
      length(Shannon[Eutrophic_Group == "Low"]) > 0 & length(Shannon[Eutrophic_Group == "High"]) > 0,
      wilcox.test(
        Shannon[Eutrophic_Group == "Low"],
        Shannon[Eutrophic_Group == "High"]
      )$p.value,
      NA
    )
  ) %>%
  mutate(
    Difference = case_when(
      Median_High > Median_Low ~ "Higher",
      Median_High < Median_Low ~ "Lower",
      TRUE ~ "Equal"
    ),
    Significance = case_when(
      P_Value < 0.05 ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )



```

# Box plot FDis
```{r}

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  group_by(Dataset) %>%
  mutate(
    Eutrophic_Group = case_when(
      TP >= quantile(TP, 0.75) ~ "High",
      TP <= quantile(TP, 0.25) ~ "Low",
      TRUE ~ "Medium"
    )
  ) %>%
  filter(Eutrophic_Group != "Medium")



data$Eutrophic_Group <- factor(data$Eutrophic_Group, levels = c("Low", "High"))

data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))


custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)



datasets_to_remove <- data %>%
  group_by(Dataset) %>%
  summarise(all_na = all(is.na(FDis))) %>%
  filter(all_na) %>%
  pull(Dataset)

# 过滤掉这些 Dataset 所对应的所有行
data_filtered <- data %>%
  filter(!Dataset %in% datasets_to_remove)

data_filtered <- data %>%
  filter(!Dataset == "PP06")

data_filtered <- data_filtered %>%
  filter(!is.na(FDis), is.finite(FDis))

Box_FDis <-
  ggplot(data_filtered, aes(x = Dataset, y = FDis, fill = Eutrophic_Group)) +
  geom_boxplot(color = "black") +  
  labs(x = "", y = "FDis") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 保留外部边框
    panel.grid = element_blank(),    # 去掉所有内部网格线
    strip.text = element_text(size = 20)  # 调整分面标签字体大小
  ) +
  scale_fill_manual(values = c("Low" = "#fce4d4", "High" = "#ffc48a")) + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 18),
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 16),
    strip.text = element_text(size = 26)  # 调整Organism标签字体大小
  ) +
  stat_compare_means(
    aes(group = Eutrophic_Group),
    method = "wilcox.test", 
    label = "p.signif", 
    size = 6,
    vjust = 1.5,
    symnum.args = list(
      cutpoints = c(0, 0.05, 1),  # 定义p值的分段
      symbols = c("*", "")       # 显著性符号：显著为“*”，非显著为空
    )
  ) +
  facet_wrap(~Organism, scales = "free", ncol = 3, nrow = 2)

plot(Box_FDis)

#ggsave("D:/Desktop/Data/R/output/Box_FDis.pdf", plot = Box_FDis, device = "pdf", width = 14, height =7)


results <- data_filtered %>%
  group_by(Dataset) %>%
  summarise(
    Median_Low = median(FDis[Eutrophic_Group == "Low"], na.rm = TRUE),
    Median_High = median(FDis[Eutrophic_Group == "High"], na.rm = TRUE),
    P_Value = ifelse(
      length(FDis[Eutrophic_Group == "Low"]) > 0 & length(FDis[Eutrophic_Group == "High"]) > 0,
      wilcox.test(
        FDis[Eutrophic_Group == "Low"],
        FDis[Eutrophic_Group == "High"]
      )$p.value,
      NA
    )
  ) %>%
  mutate(
    Difference = case_when(
      Median_High > Median_Low ~ "Higher",
      Median_High < Median_Low ~ "Lower",
      TRUE ~ "Equal"
    ),
    Significance = case_when(
      P_Value < 0.05 ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )




```

# Box plot FEve
```{r}

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  group_by(Dataset) %>%
  mutate(
    Eutrophic_Group = case_when(
      TP >= quantile(TP, 0.75) ~ "High",
      TP <= quantile(TP, 0.25) ~ "Low",
      TRUE ~ "Medium"
    )
  ) %>%
  filter(Eutrophic_Group != "Medium")



data$Eutrophic_Group <- factor(data$Eutrophic_Group, levels = c("Low", "High"))

data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
data <- data %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))


custom_order <- c("Phytoplankton", "Benthic Diatoms", "Aquatic Plants", "Zooplankton", "Benthic Macroinvertebrates", "Fish")
data$Organism <- factor(data$Organism, levels = custom_order)



datasets_to_remove <- data %>%
  group_by(Dataset) %>%
  summarise(all_na = all(is.na(FEve))) %>%
  filter(all_na) %>%
  pull(Dataset)

# 过滤掉这些 Dataset 所对应的所有行
data_filtered <- data %>%
  filter(!Dataset %in% datasets_to_remove)

data_filtered <- data %>%
  filter(!Dataset == "PP06")

data_filtered <- data_filtered %>%
  filter(!is.na(FEve), is.finite(FEve))

Box_FEve <-
  ggplot(data_filtered, aes(x = Dataset, y = FEve, fill = Eutrophic_Group)) +
  geom_boxplot(color = "black") +  
  labs(x = "", y = "FEve") +
  theme_minimal() +
  theme(
    legend.position = "right",
    panel.border = element_rect(color = "black", fill = NA, size = 1),  # 保留外部边框
    panel.grid = element_blank(),    # 去掉所有内部网格线
    strip.text = element_text(size = 20)  # 调整分面标签字体大小
  ) +
  scale_fill_manual(values = c("Low" = "#fce4d4", "High" = "#ffc48a")) + 
  theme(
    legend.position = "none",
    axis.title.y = element_text(size = 18),
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 16),
    strip.text = element_text(size = 26)  # 调整Organism标签字体大小
  ) +
  stat_compare_means(
    aes(group = Eutrophic_Group),
    method = "wilcox.test", 
    label = "p.signif", 
    size = 6,
    vjust = 1.5,
    symnum.args = list(
      cutpoints = c(0, 0.05, 1),  # 定义p值的分段
      symbols = c("*", "")       # 显著性符号：显著为“*”，非显著为空
    )
  ) +
  facet_wrap(~Organism, scales = "free", ncol = 3, nrow = 2)

plot(Box_FEve)

#ggsave("D:/Desktop/Data/R/output/Box_FEve.pdf", plot = Box_FEve, device = "pdf", width = 14, height =7)


results <- data_filtered %>%
  group_by(Dataset) %>%
  summarise(
    Median_Low = median(FEve[Eutrophic_Group == "Low"], na.rm = TRUE),
    Median_High = median(FEve[Eutrophic_Group == "High"], na.rm = TRUE),
    P_Value = ifelse(
      length(FEve[Eutrophic_Group == "Low"]) > 0 & length(FEve[Eutrophic_Group == "High"]) > 0,
      wilcox.test(
        FEve[Eutrophic_Group == "Low"],
        FEve[Eutrophic_Group == "High"]
      )$p.value,
      NA
    )
  ) %>%
  mutate(
    Difference = case_when(
      Median_High > Median_Low ~ "Higher",
      Median_High < Median_Low ~ "Lower",
      TRUE ~ "Equal"
    ),
    Significance = case_when(
      P_Value < 0.05 ~ "Significant",
      TRUE ~ "Not Significant"
    )
  )




```


# GLM_richness_diff_organisms
```{r}
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  filter(!is.na(TP), 
         !is.na(TN), 
         !is.na(pH), 
         !is.na(TS), 
         !is.na(PS), 
         !is.na(Latitude), 
         !is.na(Elevation))
data <- data %>%
  mutate(across(c(TP,TN,pH,TS,PS, Latitude, Elevation), scale))
results <- list()

# 遍历每个 Dataset 类别
for (dataset in unique(data$Dataset)) {
  
  # 提取特定 Dataset 的子集
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLM 模型
    glm_model <- glm(Richness ~ TP + TN+ pH+ TS + PS+ Latitude + Elevation, 
                     data = subset_data, 
                     family = gaussian())
    
    # 提取 GLM 模型的系数和统计信息
    summary_model <- summary(glm_model)
    glm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glm_coefficients_df <- glm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)  # 使用 dplyr::select 确保选择正确的函数
    glm_coefficients_df <- cbind(Variable = rownames(glm_coefficients_df), glm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      # 如果 partitioning 结果数量少于 GLM 变量数，用 NA 填充
      if (length(hierarchical_partitioning) < nrow(glm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      # 若无结果，则全部填充为 NA
      hierarchical_partitioning <- rep(NA, nrow(glm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Dataset = dataset,
      Data = unique(subset_data$Data),
      Organism = unique(subset_data$Organism)
    )
    
    # 重复 temp_df 的行数以匹配 glm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glm_coefficients_df)), ]
    
    Hierarchical_Partitioning = data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
colnames(empty_row) <- colnames(Hierarchical_Partitioning)
Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    # 将GLM系数和分解结果添加到表格中
    glm_results_expanded <- cbind(
      temp_df,
      glm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[dataset]] <- glm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

# 查看最终结果
print(final_result)

write.csv(final_result,file = "D:/Desktop/Data/R/output/glm_result02.csv")
```

# GLM_fric_diff_organisms
```{r}
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  filter(!is.na(TP), 
         !is.na(TN), 
         !is.na(pH), 
         !is.na(TS), 
         !is.na(PS), 
         !is.na(Latitude), 
         !is.na(Elevation))
data <- data %>%
  mutate(across(c(TP,TN,pH,TS,PS, Latitude, Elevation), scale))
results <- list()

# 遍历每个 Dataset 类别
for (dataset in unique(data$Dataset)) {
  
  # 提取特定 Dataset 的子集
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLM 模型
    glm_model <- glm(FRic ~ TP + TN+ pH+ TS + PS+ Latitude + Elevation, 
                     data = subset_data, 
                     family = gaussian())
    
    # 提取 GLM 模型的系数和统计信息
    summary_model <- summary(glm_model)
    glm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glm_coefficients_df <- glm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)  # 使用 dplyr::select 确保选择正确的函数
    glm_coefficients_df <- cbind(Variable = rownames(glm_coefficients_df), glm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      # 如果 partitioning 结果数量少于 GLM 变量数，用 NA 填充
      if (length(hierarchical_partitioning) < nrow(glm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      # 若无结果，则全部填充为 NA
      hierarchical_partitioning <- rep(NA, nrow(glm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Dataset = dataset,
      Data = unique(subset_data$Data),
      Organism = unique(subset_data$Organism)
    )
    
    # 重复 temp_df 的行数以匹配 glm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glm_coefficients_df)), ]
    
    Hierarchical_Partitioning = data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
colnames(empty_row) <- colnames(Hierarchical_Partitioning)
Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    # 将GLM系数和分解结果添加到表格中
    glm_results_expanded <- cbind(
      temp_df,
      glm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[dataset]] <- glm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

# 查看最终结果
print(final_result)

#write.csv(final_result,file = "D:/Desktop/Data/R/output/glm_fric.csv")
```

# Plot GLM_richness_fric_diff_organisms
```{r}
data_richness <- read.csv("D:/Desktop/Data/R/output/glm_result02_cleaned.csv")

data_fric <- read.csv("D:/Desktop/Data/R/output/glm_fric.csv")
# 计算每个 Organism 和 Variable 的 Importance 的 5%、95% 分位数及中位数（对 richness 的影响）
richness_stats <- data_richness %>%
  filter(!is.na(Importance)) %>%
  group_by(Organism, Variable) %>%
  summarise(
    Median = median(Importance, na.rm = TRUE),
    Percentile_5 = quantile(Importance, 0.05, na.rm = TRUE),
    Percentile_95 = quantile(Importance, 0.95, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(Data_Type = "Richness")

# 计算每个 Organism 和 Variable 的 Importance 的 5%、95% 分位数及中位数（对 FRic 的影响）
fric_stats <- data_fric %>%
  filter(!is.na(Importance)) %>%
  group_by(Organism, Variable) %>%
  summarise(
    Median = median(Importance, na.rm = TRUE),
    Percentile_5 = quantile(Importance, 0.05, na.rm = TRUE),
    Percentile_95 = quantile(Importance, 0.95, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(Data_Type = "FRic")

# 合并两个数据框
combined_stats <- bind_rows(
  richness_stats %>% rename(Importance_Median = Median, Importance_5 = Percentile_5, Importance_95 = Percentile_95),
  fric_stats %>% rename(Importance_Median = Median, Importance_5 = Percentile_5, Importance_95 = Percentile_95)
)

# 计算每个 Organism 中的 Dataset 类别数量并添加到标签中
dataset_counts <- data_richness %>%
  group_by(Organism) %>%
  summarise(Dataset_count = n_distinct(Dataset))

# 将统计信息与 combined_stats 合并
combined_stats <- combined_stats %>%
  left_join(dataset_counts, by = "Organism") %>%
  group_by(Organism) %>%
  mutate(Organism_label = paste0(Organism, " (n=", Dataset_count, ")"))

# 绘图
ggplot(combined_stats, aes(x = Importance_Median, y = Variable, color = Data_Type)) +
  geom_segment(data = subset(combined_stats, Data_Type == "Richness"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, position = position_nudge(y = 0.2)) +
  geom_point(data = subset(combined_stats, Data_Type == "Richness"),
             aes(x = Importance_Median, y = Variable),
             size = 3, position = position_nudge(y = 0.2)) +
  
  geom_segment(data = subset(combined_stats, Data_Type == "FRic"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, position = position_nudge(y = -0.2)) +
  geom_point(data = subset(combined_stats, Data_Type == "FRic"),
             aes(x = Importance_Median, y = Variable),
             size = 3, position = position_nudge(y = -0.2)) +
  
  facet_wrap(~ Organism_label, scales = "free_y", ncol = 2) +
  scale_color_manual(values = c("Richness" = "skyblue", "FRic" = "#ffbd88")) +
  labs(x = "Hierarchical Partitioning Variable Importance (%)", y = NULL, title = "") +
  guides(color = guide_legend(title = NULL)) +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank(),
        panel.grid.major = element_blank(),  # 去掉主要网格线
        panel.grid.minor = element_blank(),  # 去掉次要网格线
        strip.text = element_text(size = 12, face = "bold"),
        legend.position = "bottom",
        legend.direction = "horizontal",
        legend.justification = "center",
        legend.key.width = unit(2, "cm"))

# 保存文件
ggsave("D:/Desktop/Data/R/output/P_richness_fric.pdf", device = "pdf", width = 8, height = 8)

```

# GLM_Relative_Richness
```{r}
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  filter(!is.na(TP),
         !is.na(AT), 
         !is.na(AP))
data <- data %>%
  mutate(across(c(TP,TP2,AT,AP,TP.AP,TP.AT,TP2.AT,TP2.AP,Area,TP.Area,TP2.Area), scale))
results <- list()

# 遍历每个 Dataset 类别
for (dataset in unique(data$Dataset)) {
  
  # 提取特定 Dataset 的子集
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLM 模型
    glm_model <- glm(Relative_Richness ~ TP + TN + TP.TN+  pH +TP.pH+ AT +TP.AT+ AP+ TP.AP , 
                     data = subset_data, 
                     family = gaussian())
    
    # 提取 GLM 模型的系数和统计信息
    summary_model <- summary(glm_model)
    glm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glm_coefficients_df <- glm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)  # 使用 dplyr::select 确保选择正确的函数
    glm_coefficients_df <- cbind(Variable = rownames(glm_coefficients_df), glm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      # 如果 partitioning 结果数量少于 GLM 变量数，用 NA 填充
      if (length(hierarchical_partitioning) < nrow(glm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      # 若无结果，则全部填充为 NA
      hierarchical_partitioning <- rep(NA, nrow(glm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Dataset = dataset,
      Data = unique(subset_data$Data),
      Organism = unique(subset_data$Organism)
    )
    
    # 重复 temp_df 的行数以匹配 glm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glm_coefficients_df)), ]
    
    Hierarchical_Partitioning = data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
colnames(empty_row) <- colnames(Hierarchical_Partitioning)
Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    # 将GLM系数和分解结果添加到表格中
    glm_results_expanded <- cbind(
      temp_df,
      glm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[dataset]] <- glm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

# 查看最终结果
print(final_result)

#write.csv(final_result,file = "D:/Desktop/Data/R/output/glm_Relative_Richness.csv")





organism_dataset_counts <- final_result %>%
  group_by(Organism) %>%
  summarise(Dataset_Count = n_distinct(Dataset))

# 计算每个 Organism 和 Variable 的 5%、95% 分位数及中位数
importance_stats <- final_result %>%
  filter(!is.na(Hierarchical_Partitioning.I.perc...)) %>% # 去除Importance列中的缺失值
  group_by(Organism, Variable) %>%
  summarise(
    Median = median(Hierarchical_Partitioning.I.perc..., na.rm = TRUE),
    Percentile_5 = quantile(Hierarchical_Partitioning.I.perc..., 0.05, na.rm = TRUE),
    Percentile_95 = quantile(Hierarchical_Partitioning.I.perc..., 0.95, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  # 合并 Dataset 的数量信息
  left_join(organism_dataset_counts, by = "Organism") %>%
  # 创建一个新列，包含 Organism 和 Dataset 数量
  mutate(Organism_Label = paste(Organism, " (", Dataset_Count, ")", sep = ""))

# 绘制自定义森林图
P_Relative_Richness=ggplot(importance_stats, aes(x = Median, y = Variable)) +
  geom_segment(aes(x = Percentile_5, xend = Percentile_95, yend = Variable), 
               color = "skyblue", size = 1.2) +  # 线段表示5%到95%分位数
  geom_point(size = 3, color = "blue") +  # 中位数点
  facet_wrap(~ Organism_Label, scales = "free_y", ncol = 2) + 
  # 按 Organism 分块并显示 Dataset 数量
  labs(x = "Relative importance (%)", y = NULL, title = "") +
  theme_minimal() +
  theme(panel.grid.major.y = element_blank(),  # 隐藏y轴的网格线
        strip.text = element_text(size = 12, face = "bold"))
plot(P_Relative_Richness)

```

# GLM_Richness and FRic climate
```{r}
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  filter(!is.na(TP), 
         !is.na(AT), 
         !is.na(AP))
data <- data %>%
  mutate(across(c(TP,AT,AP, TP.AT,TP.AP), scale))
results <- list()

# 遍历每个 Dataset 类别
for (dataset in unique(data$Dataset)) {
  
  # 提取特定 Dataset 的子集
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLM 模型
    glm_model <- glm(Richness ~ TP + AT +TP.AT+ AP+ TP.AP , 
                     data = subset_data, 
                     family = gaussian())
    
    # 提取 GLM 模型的系数和统计信息
    summary_model <- summary(glm_model)
    glm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glm_coefficients_df <- glm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)  # 使用 dplyr::select 确保选择正确的函数
    glm_coefficients_df <- cbind(Variable = rownames(glm_coefficients_df), glm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      # 如果 partitioning 结果数量少于 GLM 变量数，用 NA 填充
      if (length(hierarchical_partitioning) < nrow(glm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      # 若无结果，则全部填充为 NA
      hierarchical_partitioning <- rep(NA, nrow(glm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Dataset = dataset,
      Data = unique(subset_data$Data),
      Organism = unique(subset_data$Organism)
    )
    
    # 重复 temp_df 的行数以匹配 glm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glm_coefficients_df)), ]
    
    Hierarchical_Partitioning = data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
colnames(empty_row) <- colnames(Hierarchical_Partitioning)
Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    # 将GLM系数和分解结果添加到表格中
    glm_results_expanded <- cbind(
      temp_df,
      glm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[dataset]] <- glm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

# 查看最终结果
print(final_result)

#write.csv(final_result,file = "D:/Desktop/Data/R/output/glm_New_Richness.csv")



results <- list()

# 遍历每个 Dataset 类别
for (dataset in unique(data$Dataset)) {
  
  # 提取特定 Dataset 的子集
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLM 模型
    glm_model <- glm(FRic ~ TP + AT +TP.AT+ AP+ TP.AP , 
                     data = subset_data, 
                     family = gaussian())
    
    # 提取 GLM 模型的系数和统计信息
    summary_model <- summary(glm_model)
    glm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glm_coefficients_df <- glm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)  # 使用 dplyr::select 确保选择正确的函数
    glm_coefficients_df <- cbind(Variable = rownames(glm_coefficients_df), glm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      # 如果 partitioning 结果数量少于 GLM 变量数，用 NA 填充
      if (length(hierarchical_partitioning) < nrow(glm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      # 若无结果，则全部填充为 NA
      hierarchical_partitioning <- rep(NA, nrow(glm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Dataset = dataset,
      Data = unique(subset_data$Data),
      Organism = unique(subset_data$Organism)
    )
    
    # 重复 temp_df 的行数以匹配 glm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glm_coefficients_df)), ]
    
    Hierarchical_Partitioning = data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
colnames(empty_row) <- colnames(Hierarchical_Partitioning)
Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    # 将GLM系数和分解结果添加到表格中
    glm_results_expanded <- cbind(
      temp_df,
      glm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[dataset]] <- glm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

# 查看最终结果
print(final_result)
#write.csv(final_result,file = "D:/Desktop/Data/R/output/glm_New_FRic.csv")
```

# Plot GLM P_richness_fric
```{r}
library(forcats)
data_richness <- read.csv("D:/Desktop/Data/R/output/glm_New_Richness.csv", fileEncoding = "GB18030")
data_fric <- read.csv("D:/Desktop/Data/R/output/glm_New_FRic.csv", fileEncoding = "GB18030")

data_richness <- na.omit(data_richness)
data_fric <- na.omit(data_fric)

# 计算每个 Organism 和 Variable 的 Importance 的 5%、95% 分位数及中位数（对 richness 的影响）
richness_stats <- data_richness %>%
  filter(!is.na(Importance)) %>%
  group_by(Organism, Variable) %>%
  summarise(
    Median = median(Importance, na.rm = TRUE),
    Percentile_5 = quantile(Importance, 0.05, na.rm = TRUE),
    Percentile_95 = quantile(Importance, 0.95, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(Data_Type = "Richness")

# 计算每个 Organism 和 Variable 的 Importance 的 5%、95% 分位数及中位数（对 FRic 的影响）
fric_stats <- data_fric %>%
  filter(!is.na(Importance)) %>%
  group_by(Organism, Variable) %>%
  summarise(
    Median = median(Importance, na.rm = TRUE),
    Percentile_5 = quantile(Importance, 0.05, na.rm = TRUE),
    Percentile_95 = quantile(Importance, 0.95, na.rm = TRUE)
  ) %>%
  ungroup() %>%
  mutate(Data_Type = "FRic")

# 合并两个数据框
combined_stats <- bind_rows(
  richness_stats %>% rename(Importance_Median = Median, Importance_5 = Percentile_5, Importance_95 = Percentile_95),
  fric_stats %>% rename(Importance_Median = Median, Importance_5 = Percentile_5, Importance_95 = Percentile_95)
)

# 计算每个 Organism 中的 Dataset 类别数量并添加到标签中
dataset_counts <- data_richness %>%
  group_by(Organism) %>%
  summarise(Dataset_count = n_distinct(Dataset))

# 将统计信息与 combined_stats 合并
combined_stats <- combined_stats %>%
  left_join(dataset_counts, by = "Organism") %>%
  group_by(Organism) %>%
  mutate(Organism_label = paste0(Organism, " (n=", Dataset_count, ")"))

combined_stats$Variable <- fct_rev(as.factor(combined_stats$Variable))
# 绘图
ggplot(combined_stats, aes(x = Importance_Median, y = Variable, color = Data_Type)) +
  geom_segment(data = subset(combined_stats, Data_Type == "Richness"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, position = position_nudge(y = 0.2)) +
  geom_point(data = subset(combined_stats, Data_Type == "Richness"),
             aes(x = Importance_Median, y = Variable),
             size = 3, position = position_nudge(y = 0.2)) +
  
  geom_segment(data = subset(combined_stats, Data_Type == "FRic"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, position = position_nudge(y = -0.2)) +
  geom_point(data = subset(combined_stats, Data_Type == "FRic"),
             aes(x = Importance_Median, y = Variable),
             size = 3, position = position_nudge(y = -0.2)) +
  
  facet_wrap(~ Organism_label, scales = "free_y", ncol = 2) +
  scale_color_manual(values = c("Richness" = "skyblue", "FRic" = "#ffbd88")) +
  labs(x = "Hierarchical Partitioning Variable Importance (%)", y = NULL, title = "") +
  guides(color = guide_legend(title = NULL)) +
  theme_minimal() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.major = element_blank(),  # 去掉主要网格线
    panel.grid.minor = element_blank(),  # 去掉次要网格线
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.key.width = unit(2, "cm"),
    panel.border = element_rect(color = "black", fill = NA, size = 1)  # 为每个子图添加边框
  )

# 保存文件
#ggsave("D:/Desktop/Data/R/output/P_richness_fric_climate.pdf", device = "pdf", width = 8, height = 7.5)

```

# glmmTMB test
```{r}
library(glmmTMB)
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换
library(geosphere)
library(lmerTest)
library(performance)
library(ggeffects)

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  filter(!is.na(Richness), !is.na(TP), !is.na(TP2), !is.na(AT), 
         !is.na(AP), !is.na(Area), !is.na(TP.AP), !is.na(TP.AT),
         !is.na(TP2.AT), !is.na(TP2.AP), !is.na(TP.Area), !is.na(TP2.Area))

data <- data %>%
  mutate(across(c(TP,TP2,AT,AP,TP.AP,TP.AT,TP2.AT,TP2.AP,Area,TP.Area,TP2.Area,Elevation), ~ as.numeric(scale(.))))
data <- data %>%
  group_by(Dataset) %>%
  mutate(
    Richness_scaled_local = (Richness - min(Richness)) / (max(Richness) - min(Richness))
  ) %>%
  ungroup()

# Full model
gamma_model <- glmmTMB(
  Richness ~ TP + TP2 + AT + AP + 
             TP.AP + TP.AT + TP2.AT + TP2.AP + 
             Area + TP.Area + TP2.Area + 
             (1 + TP + TP2 + AT + AP + TP.AP + TP.AT + TP2.AT + TP2.AP + TP.Area + TP2.Area | Organism/Dataset), 
  data = data,
  family = Gamma(link = "log")  # 使用 Gamma 分布和 log 链接函数
)


gamma_model2 <- glmmTMB(
  Richness ~ TP  + AT + AP + TP.AP + TP.AT +  Area +  
             (1 + TP + AT + AP + TP.AP + TP.AT +  Area | Organism/Dataset), 
  data = data,
  family = Gamma(link = "log")  # 使用 Gamma 分布和 log 链接函数
)

gamma_model3 <- glmmTMB(
  Richness ~ TP  +  TP2 + AT + AP + TP.AP + TP.AT + TP2.AP + TP2.AT+  Area +  
             (1 | Organism/Dataset), 
  data = data,
  family = Gamma(link = "log")  # 使用 Gamma 分布和 log 链接函数
)

gamma_model4 <- glmmTMB(
  Richness ~ TP  +  TP2 + AT + AP + TP.AP + TP.AT + TP2.AP + TP2.AT+  Area +  
             (1+ TP + TP2 + AT + AP | Organism/Dataset), 
  data = data,
  family = Gamma(link = "log")  # 使用 Gamma 分布和 log 链接函数
)

gamma_model5 <- glmmTMB(
  Richness ~ TP + TP2 + AT + AP + TP:AP + TP:AT + TP2.AP + TP2.AT+ Area +
             (1 | Dataset) +
             (1 + TP + TP2 + AT + AP + TP:AP + TP:AT + TP2.AP + TP2.AT | Organism),
  data = data,
  family = Gamma(link = "log")  # 假设 Richness 服从 Gamma 分布
)


# Now
model <- glmmTMB(
  Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + TP2.AT + TP2.AP + Elevation+ Area +
    (TP + TP2 | Dataset) + (1 | Organism) ,
  data = data,
  family = Gamma(link = "log")
)


model <- lmer(
  Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + TP2.AT + TP2.AP + Elevation+ Area +
    (TP+TP2 | Dataset) + (1 | Organism) ,
  data = data,)


model1 <- lmer(
  Richness_scaled ~ TP + TP2 + AT + AP + TP.AT + TP.AP + TP2.AT + TP2.AP + Elevation+ Area + (1 | Organism) ,data = data)
model2 <- lmer(
  Richness_scaled ~ TP + TP2 + AT + AP + TP.AT + TP.AP + TP2.AT + TP2.AP + Elevation+ Area + (1 |Organism/Dataset),
  data = data)
model3 <- lmer(
  Richness_scaled ~ TP + AT + AP + TP.AT + TP.AP + Area + Elevation + (1 | Organism) ,
  data = data
)
model4 <- lmer(
  Richness ~ TP + AT + AP + TP.AT + TP.AP + Area + Elevation + (1 | Organism) ,
  data = data
)

summary(model1)
summary(model2)
summary(model3)
summary(model4)
r2(model1)
r2(model2)
r2(model3)
r2(model4)
glmmhp1 <- glmm.hp(model1)
glmmhp1$hierarchical.partitioning
glmmhp2 <- glmm.hp(model2)
glmmhp2$hierarchical.partitioning

model3 <- lmer(
  Richness_scaled ~ TP + TP2 + AT + AP + TP.AT + TP.AP + TP2.AT + TP2.AP + Elevation +
    (1 | Area ) + (1 | Organism) ,
  data = data
)
r2(model_random)



model3 <- lmer(
  Richness_scaled ~ TP + TP2 + AT + AP + TP.AT + TP.AP + TP2.AT + TP2.AP + Elevation +
    (1 | Area ) + (1 | Organism) ,
  data = data
)








```

# TEST
```{r}
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
datasets_to_skip <- c("LFIAP_2", "LSWAP", "LUSAP", "LUSAP_2")
data <- data %>% filter(!Dataset %in% datasets_to_skip)

data <- data %>%
  mutate(
    # 对响应变量进行 log(x+1) 转换和标准化
    Richness = scale(log(Richness + 1))[, 1],
    FRic = scale(log(FRic + 1))[, 1],
    
    # 对解释变量进行 log(x+1) 转换和标准化
    across(
      c(TP, AT, AP, TP.AP, TP.AT, AL, Elevation),
      ~ scale(log(. - min(., na.rm = TRUE) + 1))[, 1]
    )
  )


model<- lmer ( Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + AL + Elevation + (1 | Organism), data = data)
r2(model)

model<- lmer ( Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + AL + Elevation + (1 | Dataset ), data = data)
r2(model)

model<- lmer ( Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + AL + Elevation +   (1 | Dataset ) + (1 | Organism) ,  data = data)
r2(model)

model <- lmer ( Relative_Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + AL+ Elevation + (1 | Organism) ,  data = data)
r2(model)

model <- lmer ( Relative_Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + AL+ Elevation +   (1 | Dataset ),  data = data)
r2(model)

model <- lmer ( Relative_Richness ~ TP + TP2 + AT + AP + TP.AT + TP.AP + AL + Elevation  +   (1 | Dataset ) + (1 | Organism) ,data = data)
r2(model)

```

# Every Dataset
```{r}
library(glmmTMB)
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换
library(geosphere)
library(lmerTest)
library(performance)
library(ggeffects)
library(broom.mixed)
library(mgcv)
library(corrplot)
cor_data <- data %>% select(TP, AT, AP, TP.AT, TP.AP, Elevation, AL)

# 计算相关性矩阵（使用 Pearson）
cor_matrix <- cor(cor_data, use = "complete.obs", method = "pearson")
corrplot(cor_matrix, method = "color", type = "upper", tl.col = "black", tl.srt = 45,
         title = "Correlation Matrix", addCoef.col = "black", number.cex = 0.7)

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
sapply(data[, c("TP", "AT", "AP", "TP.AP", "TP.AT", "AL", "Elevation")], min, na.rm = TRUE)
# 对转换后的数值列进行标准化
datasets_to_skip <- c("LFIAP_2", "LSWAP", "LUSAP", "LUSAP_2")
data <- data %>% filter(!Dataset %in% datasets_to_skip)

data <- data %>%
  mutate(
    # 对响应变量进行 log(x+1) 转换和标准化
    Richness = scale(log(Richness + 1))[, 1],
    FRic = scale(log(FRic + 1))[, 1],
    
    # 对解释变量进行 log(x+1) 转换和标准化
    across(
      c(TP, AT, AP, TP.AP, TP.AT, AL, Elevation),
      ~ scale(log(. - min(., na.rm = TRUE) + 1))[, 1]
    )
  )

# Old
# data <- data %>%   mutate(across(c(TP, AT, AP, TP.AP, TP.AT, AL, Elevation, X, Y, TP2, TP2.AT, TP2.AP,TS,PS),     ~ scale(as.numeric(.))))



#Richness
results <- data.frame(
  Dataset = character(),   # 数据集名称
  Variable = character(),  # 自变量名称
  Estimate = numeric(),    # GLM 参数估计值
  Std.Error = numeric(),   # 标准误差
  t.value = numeric(),     # t 值
  Pr.t = numeric(),        # P 值
  Unique = numeric(),      # Hierarchical Partitioning: Unique
  Average.Share = numeric(), # Hierarchical Partitioning: Average Share
  Individual = numeric(),  # Hierarchical Partitioning: Individual
  I.perc = numeric(),      # Hierarchical Partitioning: I.perc(%)
  R2 = numeric(),          # GLM 的 R 平方
  stringsAsFactors = FALSE
)
unique_datasets <- unique(data$Dataset)

# 遍历每个 Dataset
for (dataset in unique_datasets) {
  # 筛选出当前 Dataset 的数据
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的数据点进行建模
  if (nrow(subset_data) > 5) {  # 假设至少需要 5 个点
    # 添加 log_Richness 列
    #subset_data$log_Richness <- log(subset_data$Richness)
    
    # GLM 模型
    glm_model <- glm(Richness ~ TP + AT + AP + AL + Elevation,
                     data = subset_data, 
                     #family = Gamma(link = "log")
                     family = gaussian(link = "identity"))
    
    # 计算 GLM 的 R 平方
    glm_r2 <- 1 - (glm_model$deviance / glm_model$null.deviance)
    
    # 提取 GLM 参数结果
    glm_summary <- summary(glm_model)$coefficients  # 获取参数估计结果
    
    # 使用 glmm.hp
    glmmhp_results <- glmm.hp(glm_model)
    hp_df <- as.data.frame(glmmhp_results$hierarchical.partitioning)  # 转为数据框
    hp_df$Variable <- rownames(hp_df)  # 添加 Variable 列
    
    # 遍历每个变量，将结果存入数据框
    for (var in rownames(glm_summary)) {
      # 如果变量在 Hierarchical Partitioning 中，提取对应值；否则填 NA
      if (var %in% hp_df$Variable) {
        hp_row <- hp_df[hp_df$Variable == var, ]
        unique_val <- hp_row$Unique
        avg_share_val <- hp_row$Average.share
        individual_val <- hp_row$Individual
        iperc_val <- hp_row$I.perc
      } else {
        unique_val <- NA
        avg_share_val <- NA
        individual_val <- NA
        iperc_val <- NA
      }
      
      # 添加结果到结果数据框
      results <- rbind(
        results,
        data.frame(
          Dataset = dataset,
          Variable = var,
          Estimate = glm_summary[var, "Estimate"],
          Std.Error = glm_summary[var, "Std. Error"],
          t.value = glm_summary[var, "t value"],
          Pr.t = glm_summary[var, "Pr(>|t|)"],
          Unique = unique_val,
          Average.Share = avg_share_val,
          Individual = individual_val,
          I.perc = iperc_val,
          R2 = glm_r2,  # 添加 GLM 的 R 平方
          stringsAsFactors = FALSE
        )
      )
    }
  }
}

# 查看结果数据框
head(results)

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
additional_info <- data %>%
  group_by(Dataset) %>%
  summarize(
    Organism = first(Organism),  # 提取每个 Dataset 的 Organism
    Data = first(Data),          # 提取每个 Dataset 的 Data
    Area = first(Area),          # 提取每个 Dataset 的 Area
    Num = n()                      # 每个 Dataset 的样本数量
  )
results <- merge(results, additional_info, by = "Dataset", all.x = TRUE)
# 保存结果到 CSV 文件
#write.csv(results, "D:/Desktop/Data/R/output/Results_Richness3.csv", row.names = FALSE)


#FRic

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")

datasets_to_skip <- c("LFIAP_2", "LSWAP", "LUSAP", "LUSAP_2")
data <- data %>% filter(!Dataset %in% datasets_to_skip)

data <- data %>%
  mutate(
    # 对响应变量进行 log(x+1) 转换和标准化
    Richness = scale(log(Richness + 1))[, 1],
    FRic = scale(log(FRic + 1))[, 1],
    
    # 对解释变量进行 log(x+1) 转换和标准化
    across(
      c(TP, AT, AP, TP.AP, TP.AT, AL, Elevation),
      ~ scale(log(. - min(., na.rm = TRUE) + 1))[, 1]
    )
  )
#data <- data %>%   mutate(across(c(TP,AT,AP,TP.AP,TP.AT,AL,Elevation,X,Y,TP2,TP2.AT,TP2.AP,TS,PS), ~ scale(.)))



results <- data.frame(
  Dataset = character(),   # 数据集名称
  Variable = character(),  # 自变量名称
  Estimate = numeric(),    # GLM 参数估计值
  Std.Error = numeric(),   # 标准误差
  t.value = numeric(),     # t 值
  Pr.t = numeric(),        # P 值
  Unique = numeric(),      # Hierarchical Partitioning: Unique
  Average.Share = numeric(), # Hierarchical Partitioning: Average Share
  Individual = numeric(),  # Hierarchical Partitioning: Individual
  I.perc = numeric(),      # Hierarchical Partitioning: I.perc(%)
  R2 = numeric(),          # GLM 的 R 平方
  stringsAsFactors = FALSE
)
unique_datasets <- unique(data$Dataset)

# 遍历每个 Dataset
for (dataset in unique_datasets) {
  # 筛选出当前 Dataset 的数据
  subset_data <- subset(data, Dataset == dataset)
  
  # 检查是否有足够的数据点进行建模
  if (nrow(subset_data) > 5) {  # 假设至少需要 5 个点
    # 添加 log_Richness 列
    #subset_data$log_Richness <- log(subset_data$FRic)
    
    # GLM 模型
    glm_model <- glm(FRic ~  TP + AT + AP  + AL + Elevation,
                     data = subset_data, 
                     family = gaussian(link = "identity")
                     #family = Gamma(link = "log")
                     )
    
    # 计算 GLM 的 R 平方
    glm_r2 <- 1 - (glm_model$deviance / glm_model$null.deviance)
    
    # 提取 GLM 参数结果
    glm_summary <- summary(glm_model)$coefficients  # 获取参数估计结果
    # 使用 glmm.hp
    glmmhp_results <- glmm.hp(glm_model)
    hp_df <- as.data.frame(glmmhp_results$hierarchical.partitioning)  # 转为数据框
    hp_df$Variable <- rownames(hp_df)  # 添加 Variable 列
    
    # 遍历每个变量，将结果存入数据框
    for (var in rownames(glm_summary)) {
      # 如果变量在 Hierarchical Partitioning 中，提取对应值；否则填 NA
      if (var %in% hp_df$Variable) {
        hp_row <- hp_df[hp_df$Variable == var, ]
        unique_val <- hp_row$Unique
        avg_share_val <- hp_row$Average.share
        individual_val <- hp_row$Individual
        iperc_val <- hp_row$I.perc
      } else {
        unique_val <- NA
        avg_share_val <- NA
        individual_val <- NA
        iperc_val <- NA
      }
      
      # 添加结果到结果数据框
      results <- rbind(
        results,
        data.frame(
          Dataset = dataset,
          Variable = var,
          Estimate = glm_summary[var, "Estimate"],
          Std.Error = glm_summary[var, "Std. Error"],
          t.value = glm_summary[var, "t value"],
          Pr.t = glm_summary[var, "Pr(>|t|)"],
          Unique = unique_val,
          Average.Share = avg_share_val,
          Individual = individual_val,
          I.perc = iperc_val,
          R2 = glm_r2,  # 添加 GLM 的 R 平方
          stringsAsFactors = FALSE
        )
      )
    }
  }
}

# 查看结果数据框
head(results)

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
additional_info <- data %>%
  group_by(Dataset) %>%
  summarize(
    Organism = first(Organism),  # 提取每个 Dataset 的 Organism
    Data = first(Data),          # 提取每个 Dataset 的 Data
    Area = first(Area),          # 提取每个 Dataset 的 Area
    Num = n()                      # 每个 Dataset 的样本数量
  )
results <- merge(results, additional_info, by = "Dataset", all.x = TRUE)
# 保存结果到 CSV 文件
#write.csv(results, "D:/Desktop/Data/R/output/Results_FRic3.csv", row.names = FALSE)
```

# Forest plot Lake and River
```{r}

library(effsize)

richness_data=read.csv("D:/Desktop/Data/R/output/Results_Richness.csv")
fric_data=read.csv("D:/Desktop/Data/R/output/Results_FRic.csv")

richness_data <- richness_data %>%
  mutate(Data_Type = "Richness")

fric_data <- fric_data %>%
  mutate(Data_Type = "FRic")

combined_data <- rbind(richness_data, fric_data)
combined_data <- combined_data %>%
  filter(Variable != "(Intercept)")

# Lake
combined_stats <- combined_data %>%
  filter(Data == "Lake") %>%
  group_by(Variable, Data_Type) %>%
  summarise(
    # 计算相对重要性的中位数和置信区间
    Importance_Median = median(I.perc, na.rm = TRUE),
    Importance_5 = mean(I.perc) - 1.96 * sd(I.perc) / sqrt(n()),
    Importance_95 = mean(I.perc) + 1.96 * sd(I.perc) / sqrt(n()),
    
    # 正相关比例
    Positive_Proportion = mean(Estimate > 0, na.rm = TRUE) * 100,
    
    # 统计显著的个数（p-value < 0.05）
    Significant_Count = sum(Pr.t < 0.05, na.rm = TRUE),
    
    .groups = "drop"
  ) %>%
  mutate(
    # 分类圆圈大小
    Size = case_when(
      Positive_Proportion >= 75 ~ "75%",     # 75-100
      Positive_Proportion >= 50 ~ "50%",    # 50-75
      Positive_Proportion >= 25 ~ "25%",    # 25-50
      TRUE ~ "0%"                            # 0-25
    )
  )


lake_data <- combined_data %>%
  filter(Data == "Lake")

river_data <- combined_data %>%
  filter(Data == "River")

significant_counts_L <- lake_data %>%
  mutate(Significant = ifelse(Pr.t < 0.05, 1, 0)) %>% # 标记显著
  group_by(Variable, Data_Type) %>%                   # 按因子和多样性指数分组
  summarise(Significant_Count = sum(Significant, na.rm = TRUE), # 统计显著个数
            Total_Count = n(),                           # 总个数
            Proportion = Significant_Count / Total_Count # 计算比例
  ) %>%
  arrange(Data_Type, desc(Significant_Count))            # 排序


significant_counts_R <- river_data %>%
  mutate(Significant = ifelse(Pr.t < 0.05, 1, 0)) %>% # 标记显著
  group_by(Variable, Data_Type) %>%                   # 按因子和多样性指数分组
  summarise(Significant_Count = sum(Significant, na.rm = TRUE), # 统计显著个数
            Total_Count = n(),                           # 总个数
            Proportion = Significant_Count / Total_Count # 计算比例
  ) %>%
  arrange(Data_Type, desc(Significant_Count))            # 排序


calculate_hedges_d <- function(x1, x2) {
  n1 <- length(x1)
  n2 <- length(x2)
  s1 <- sd(x1)
  s2 <- sd(x2)
  pooled_sd <- sqrt(((n1 - 1) * s1^2 + (n2 - 1) * s2^2) / (n1 + n2 - 2))
  d <- (mean(x1) - mean(x2)) / pooled_sd
  correction_factor <- 1 - (3 / (4 * (n1 + n2) - 9))
  hedges_d <- d * correction_factor
  return(hedges_d)
}

# 使用数据框来计算每个因子的 Hedges' d
effect_size_data_R <- river_data %>%
  group_by(Variable) %>%
  summarise(
    # 提取Richness和FRic的I.perc值
    I_perc_richness = list(I.perc[Data_Type == "Richness"]),
    I_perc_fric = list(I.perc[Data_Type == "FRic"]),
    
    # 计算Hedges' d
    effect_size = calculate_hedges_d(unlist(I_perc_richness), unlist(I_perc_fric)),
    
    # 进行配对样本 t 检验
    t_test_result = list(t.test(unlist(I_perc_richness), unlist(I_perc_fric), paired = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(
    # 提取t检验的p-value
    p_value = sapply(t_test_result, function(x) x$p.value)
  )

# 查看每个因子的效应大小和p-value
print(effect_size_data)







library(ggplot2)

ggplot(combined_stats, aes(x = Importance_Median, y = Variable, color = Data_Type)) +
  # Richness 数据的所有相对重要性值（透明蓝色圆圈）
  geom_point(data = subset(combined_data, Data_Type == "Richness"),
             aes(x = I.perc, y = Variable),
             color = "#d2ddf1", alpha = 0.3, size = 3,
             position = position_nudge(y = 0.2)) +
  
  # FRic 数据的所有相对重要性值（透明橙色圆圈）
  geom_point(data = subset(combined_data, Data_Type == "FRic"),
             aes(x = I.perc, y = Variable),
             color = "#fce4d4", alpha = 0.3, size = 3,
             position = position_nudge(y = -0.2)) +
  
  # Richness 数据的置信区间（深蓝色）
  geom_segment(data = subset(combined_stats, Data_Type == "Richness"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, color = "#547ac0", position = position_nudge(y = 0.2)) +
  # Richness 数据的中位点（深蓝色）
  geom_point(data = subset(combined_stats, Data_Type == "Richness"),
             aes(x = Importance_Median, size = Size),
             color = "#547ac0", position = position_nudge(y = 0.2)) +
  
  # FRic 数据的置信区间（深橙色）
  geom_segment(data = subset(combined_stats, Data_Type == "FRic"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, color = "#ffc48a", position = position_nudge(y = -0.2)) +
  # FRic 数据的中位点（深橙色）
  geom_point(data = subset(combined_stats, Data_Type == "FRic"),
             aes(x = Importance_Median, size = Size),
             color = "#ffc48a", position = position_nudge(y = -0.2)) +
  
  # 自定义圆圈大小比例（调整差异范围）
  scale_size_manual(
    values = c("0%" = 3, "25%" = 4, "50%" = 5, "75%" = 6), 
    name = "Positive Proportion (%)"
  ) +
  # 图形设置
  labs(x = "Hierarchical Partitioning Importance (%)", 
       y = NULL, title = "Lake") +
  guides(color = "none") + # 去掉颜色图例（因为颜色已经在代码中显式设置）
  theme_minimal() +
  theme(
    panel.border = element_blank(), # 移除整个边框
    axis.line.x = element_line(color = "black"), # 添加底部框线
    axis.ticks.x = element_line(color = "black"), # 添加底部刻度
    axis.ticks.length = unit(0.25, "cm"),       # 调整刻度长度
    panel.grid.major.y = element_blank(),       # 去掉主要网格线
    panel.grid.major = element_blank(),         # 去掉主要网格线
    panel.grid.minor = element_blank(),         # 去掉次要网格线
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.key.width = unit(2, "cm"),
    # 调整标题和轴标签的字体大小
    plot.title = element_text(size = 18, hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14, face = "bold"), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12)  # y轴刻度
  )

#ggsave("D:/Desktop/Data/R/output/Lake2.pdf", device = "pdf", width = 10, height = 4.5)



# River
combined_stats <- combined_data %>%
  filter(Data == "River") %>%
  group_by(Variable, Data_Type) %>%
  summarise(
    # 计算相对重要性的中位数和置信区间
    Importance_Median = median(I.perc, na.rm = TRUE),
    Importance_5 = mean(I.perc) - 1.96 * sd(I.perc) / sqrt(n()),
    Importance_95 = mean(I.perc) + 1.96 * sd(I.perc) / sqrt(n()),
    
    # 正相关比例
    Positive_Proportion = mean(Estimate > 0, na.rm = TRUE) * 100,
    
    # 统计显著的个数（p-value < 0.05）
    Significant_Count = sum(Pr.t < 0.05, na.rm = TRUE),
    
    .groups = "drop"
  ) %>%
  mutate(
    # 分类圆圈大小
    Size = case_when(
      Positive_Proportion >= 75 ~ "75%",     # 75-100
      Positive_Proportion >= 50 ~ "50%",    # 50-75
      Positive_Proportion >= 25 ~ "25%",    # 25-50
      TRUE ~ "0%"                            # 0-25
    )
  )



library(ggplot2)

ggplot(combined_stats, aes(x = Importance_Median, y = Variable, color = Data_Type)) +
  # Richness 数据的所有相对重要性值（透明蓝色圆圈）
  geom_point(data = subset(combined_data, Data_Type == "Richness"),
             aes(x = I.perc, y = Variable),
             color = "#d2ddf1", alpha = 0.3, size = 3,
             position = position_nudge(y = 0.2)) +
  
  # FRic 数据的所有相对重要性值（透明橙色圆圈）
  geom_point(data = subset(combined_data, Data_Type == "FRic"),
             aes(x = I.perc, y = Variable),
             color = "#fce4d4", alpha = 0.3, size = 3,
             position = position_nudge(y = -0.2)) +
  
  # Richness 数据的置信区间（深蓝色）
  geom_segment(data = subset(combined_stats, Data_Type == "Richness"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, color = "#547ac0", position = position_nudge(y = 0.2)) +
  # Richness 数据的中位点（深蓝色）
  geom_point(data = subset(combined_stats, Data_Type == "Richness"),
             aes(x = Importance_Median, size = Size),
             color = "#547ac0", position = position_nudge(y = 0.2)) +
  
  # FRic 数据的置信区间（深橙色）
  geom_segment(data = subset(combined_stats, Data_Type == "FRic"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, color = "#ffc48a", position = position_nudge(y = -0.2)) +
  # FRic 数据的中位点（深橙色）
  geom_point(data = subset(combined_stats, Data_Type == "FRic"),
             aes(x = Importance_Median, size = Size),
             color = "#ffc48a", position = position_nudge(y = -0.2)) +
  
  # 自定义圆圈大小比例（调整差异范围）
  scale_size_manual(
    values = c("0%" = 3, "25%" = 4, "50%" = 5, "75%" = 6), 
    name = "Positive Proportion (%)"
  ) +
  
  # 图形设置
  labs(x = "Hierarchical Partitioning Importance (%)", 
       y = NULL, title = "River") +
  guides(color = "none") + # 去掉颜色图例（因为颜色已经在代码中显式设置）
  theme_minimal() +
  theme(
    panel.border = element_blank(), # 移除整个边框
    axis.line.x = element_line(color = "black"), # 添加底部框线
    axis.ticks.x = element_line(color = "black"), # 添加底部刻度
    axis.ticks.length = unit(0.25, "cm"),       # 调整刻度长度
    panel.grid.major.y = element_blank(),       # 去掉主要网格线
    panel.grid.major = element_blank(),         # 去掉主要网格线
    panel.grid.minor = element_blank(),         # 去掉次要网格线
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.key.width = unit(2, "cm"),
    # 调整标题和轴标签的字体大小
    plot.title = element_text(size = 18, hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14, face = "bold"), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12)  # y轴刻度
  )

#ggsave("D:/Desktop/Data/R/output/River.pdf", device = "pdf", width = 6.5, height = 4.5)
```

#2222
```{r}
combined_stats <- combined_stats %>%
  left_join(effect_size_data, by = "Variable")

# 绘制图并标注效应大小
ggplot(combined_stats, aes(x = Importance_Median, y = Variable, color = Data_Type)) +
  # Richness 数据的所有相对重要性值（透明蓝色圆圈）
  geom_point(data = subset(combined_data, Data_Type == "Richness"),
             aes(x = I.perc, y = Variable),
             color = "#d2ddf1", alpha = 0.3, size = 3,
             position = position_nudge(y = 0.2)) +
  
  # FRic 数据的所有相对重要性值（透明橙色圆圈）
  geom_point(data = subset(combined_data, Data_Type == "FRic"),
             aes(x = I.perc, y = Variable),
             color = "#fce4d4", alpha = 0.3, size = 3,
             position = position_nudge(y = -0.2)) +
  
  # Richness 数据的置信区间（深蓝色）
  geom_segment(data = subset(combined_stats, Data_Type == "Richness"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, color = "#547ac0", position = position_nudge(y = 0.2)) +
  # Richness 数据的中位点（深蓝色）
  geom_point(data = subset(combined_stats, Data_Type == "Richness"),
             aes(x = Importance_Median, size = Size),
             color = "#547ac0", position = position_nudge(y = 0.2)) +
  
  # FRic 数据的置信区间（深橙色）
  geom_segment(data = subset(combined_stats, Data_Type == "FRic"),
               aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
               size = 1.2, color = "#ffc48a", position = position_nudge(y = -0.2)) +
  # FRic 数据的中位点（深橙色）
  geom_point(data = subset(combined_stats, Data_Type == "FRic"),
             aes(x = Importance_Median, size = Size),
             color = "#ffc48a", position = position_nudge(y = -0.2)) +
  
  # 在每个变量旁标注效应大小
  geom_text(data = combined_stats, 
            aes(x = max(Importance_95, na.rm = TRUE) + 1,  # 将注释放在置信区间右侧
                y = Variable, 
                label = paste0("d = ", round(effect_size, 2))),
            color = "black", size = 4, hjust = 0) +
  
  # 自定义圆圈大小比例（调整差异范围）
  scale_size_manual(
    values = c("0%" = 3, "25%" = 4, "50%" = 5, "75%" = 6), 
    name = "Positive Proportion (%)"
  ) +
  # 图形设置
  labs(x = "Hierarchical Partitioning Importance (%)", 
       y = NULL, title = "Lake") +
  guides(color = "none") + # 去掉颜色图例（因为颜色已经在代码中显式设置）
  theme_minimal() +
  theme(
    panel.border = element_blank(), # 移除整个边框
    axis.line.x = element_line(color = "black"), # 添加底部框线
    axis.ticks.x = element_line(color = "black"), # 添加底部刻度
    axis.ticks.length = unit(0.25, "cm"),       # 调整刻度长度
    panel.grid.major.y = element_blank(),       # 去掉主要网格线
    panel.grid.major = element_blank(),         # 去掉主要网格线
    panel.grid.minor = element_blank(),         # 去掉次要网格线
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.key.width = unit(2, "cm"),
    # 调整标题和轴标签的字体大小
    plot.title = element_text(size = 18, hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14, face = "bold"), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12)  # y轴刻度
  )
```

# Sig Lake and River
```{r}

combined_data <- combined_data %>%
  filter(Data %in% c("Lake", "River"))

p_values <- combined_data %>%
  group_by(Variable) %>%
  summarise(
    p_value = t.test(I.perc[Data == "Lake"], I.perc[Data == "River"])$p.value
  ) %>%
  mutate(
    significance = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

max_values <- combined_data %>%
  group_by(Variable, Data) %>%
  summarise(max_value = max(I.perc, na.rm = TRUE), .groups = "drop") %>%
  group_by(Variable) %>%
  summarise(y_position = max(max_value) + 0.1)

# 合并显著性位置和标记
p_values <- p_values %>%
  left_join(max_values, by = "Variable")

# 绘制箱型图
p <- ggplot(combined_data, aes(x = Variable, y = I.perc, fill = Data)) +
  geom_boxplot(position = position_dodge(0.8), width = 0.7) +
  labs(
    title = "Relative Importance of Variables in Lake and River",
    x = "Variable",
    y = "Relative Importance (I.perc)"
  ) +
  theme_minimal() +
  scale_fill_manual(
    values = c("#00AFBB", "#E7B800"),
    name = "Data Type"
  )

# 添加显著性标记
p <- p +
  geom_segment(
    data = p_values,
    aes(x = as.numeric(as.factor(Variable)) - 0.2,
        xend = as.numeric(as.factor(Variable)) + 0.2,
        y = y_position, yend = y_position),
    inherit.aes = FALSE,
    size = 0.5
  ) +
  geom_text(
    data = p_values,
    aes(x = as.numeric(as.factor(Variable)),
        y = y_position + 0.05,
        label = significance),
    inherit.aes = FALSE,
    size = 4
  )

# 显示图形
print(p)
```

# Sig Organism
```{r}
library(ggplot2)
library(dplyr)
library(tidyr)

# 筛选数据并确保列名正确
combined_data <- combined_data %>%
  filter(!is.na(Organism))

# 使用 pairwise.t.test 比较每个 Variable 不同 Organism 的两两显著性
pairwise_results <- combined_data %>%
  group_by(Variable) %>%
  summarise(
    pairwise_p = list(pairwise.t.test(
      I.perc,
      Organism,
      p.adjust.method = "bonferroni"
    )),
    .groups = "drop"
  )

# 提取两两显著性结果
p_values <- pairwise_results %>%
  rowwise() %>%
  mutate(pairs = list(as.data.frame(pairwise_p$p.value))) %>%
  select(Variable, pairs) %>%
  unnest(cols = c(pairs)) %>%
  pivot_longer(-Variable, names_to = "Comparison", values_to = "p_value") %>%
  separate(Comparison, into = c("Organism_1", "Organism_2"), sep = "\\.") %>%
  mutate(
    significance = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  ) %>%
  filter(!is.na(p_value))  # 过滤 NA 值

# 确定每对比较的显著性标记位置
max_values <- combined_data %>%
  group_by(Variable, Organism) %>%
  summarise(max_value = max(I.perc, na.rm = TRUE), .groups = "drop") %>%
  group_by(Variable) %>%
  summarise(y_position = max(max_value) + 0.2)

p_values <- p_values %>%
  left_join(max_values, by = "Variable") %>%
  group_by(Variable) %>%
  mutate(y_position = y_position + 0.3 * (row_number() - 1))  # 调整位置避免重叠

# 绘制分裂小图的箱型图
p <- ggplot(combined_data, aes(x = Organism, y = I.perc, fill = Organism)) +
  geom_boxplot(position = position_dodge(0.8), width = 0.7) +
  facet_wrap(~Variable, scales = "free_y") +  # 按 Variable 分裂小图
  labs(
    title = "Relative Importance of Variables Across Organisms",
    x = "Organism",
    y = "Relative Importance (I.perc)"
  ) +
  theme_minimal() +
  theme(
    strip.text = element_text(size = 10, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_fill_manual(
    values = c("#00AFBB", "#E7B800", "#FC4E07", "#9999FF", "#66CC99", "#FF6666"),
    name = "Organism"
  )

# 添加显著性标记
p <- p +
  geom_segment(
    data = p_values,
    aes(x = as.numeric(as.factor(Organism_1)),
        xend = as.numeric(as.factor(Organism_2)),
        y = y_position, yend = y_position),
    inherit.aes = FALSE,
    size = 0.5
  ) +
  geom_text(
    data = p_values,
    aes(x = (as.numeric(as.factor(Organism_1)) + as.numeric(as.factor(Organism_2))) / 2,
        y = y_position + 0.05,
        label = significance),
    inherit.aes = FALSE,
    size = 3
  )

# 显示图形
print(p)


```

# Forest plot Organism
```{r}
unique_organisms <- unique(combined_data$Organism)
library(ggplot2)

plot_for_organism <- function(data, organism_name) {
  data <- data %>% filter(Organism == organism_name) # 筛选当前类群的数据
  
  stats <- data %>%
    group_by(Variable, Data_Type) %>%
    summarise(
      Importance_Median = median(I.perc, na.rm = TRUE),
      Importance_5 = mean(I.perc, na.rm = TRUE) - 1.96 * sd(I.perc, na.rm = TRUE) / sqrt(n()),
      Importance_95 = mean(I.perc, na.rm = TRUE) + 1.96 * sd(I.perc, na.rm = TRUE) / sqrt(n()),
      Positive_Proportion = mean(Estimate > 0, na.rm = TRUE) * 100,
      .groups = "drop"
    ) %>%
    mutate(
      Size = case_when(
        Positive_Proportion >= 75 ~ "75%",
        Positive_Proportion >= 50 ~ "50%",
        Positive_Proportion >= 25 ~ "25%",
        TRUE ~ "0%"
      )
    )
  
  ggplot(stats, aes(x = Importance_Median, y = Variable, color = Data_Type)) +
    # Richness 数据的相对重要性
    geom_point(data = subset(data, Data_Type == "Richness"),
               aes(x = I.perc, y = Variable),
               color = "#d2ddf1", alpha = 0.3, size = 3,
               position = position_nudge(y = 0.2)) +
    
    # FRic 数据的相对重要性
    geom_point(data = subset(data, Data_Type == "FRic"),
               aes(x = I.perc, y = Variable),
               color = "#fce4d4", alpha = 0.3, size = 3,
               position = position_nudge(y = -0.2)) +
    
    # Richness 的置信区间
    geom_segment(data = subset(stats, Data_Type == "Richness"),
                 aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
                 size = 1.2, color = "#547ac0", position = position_nudge(y = 0.2)) +
    geom_point(data = subset(stats, Data_Type == "Richness"),
               aes(x = Importance_Median, size = Size),
               color = "#547ac0", position = position_nudge(y = 0.2)) +
    
    # FRic 的置信区间
    geom_segment(data = subset(stats, Data_Type == "FRic"),
                 aes(x = Importance_5, xend = Importance_95, y = Variable, yend = Variable),
                 size = 1.2, color = "#ffc48a", position = position_nudge(y = -0.2)) +
    geom_point(data = subset(stats, Data_Type == "FRic"),
               aes(x = Importance_Median, size = Size),
               color = "#ffc48a", position = position_nudge(y = -0.2)) +
    
    scale_size_manual(
      values = c("0%" = 3, "25%" = 4, "50%" = 5, "75%" = 6),
      name = "Positive Proportion (%)"
    ) +
    labs(x = "Hierarchical Partitioning Importance (%)", 
         y = NULL, title = organism_name) +
    guides(color = "none") +
    theme_minimal() +
    theme(
    panel.border = element_blank(), # 移除整个边框
    axis.line.x = element_line(color = "black"), # 添加底部框线
    axis.ticks.x = element_line(color = "black"), # 添加底部刻度
    axis.ticks.length = unit(0.25, "cm"),       # 调整刻度长度
    panel.grid.major.y = element_blank(),       # 去掉主要网格线
    panel.grid.major = element_blank(),         # 去掉主要网格线
    panel.grid.minor = element_blank(),         # 去掉次要网格线
    strip.text = element_text(size = 12, face = "bold"),
    legend.position = "bottom",
    legend.direction = "horizontal",
    legend.justification = "center",
    legend.key.width = unit(2, "cm"),
    # 调整标题和轴标签的字体大小
    plot.title = element_text(size = 18, hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14, face = "bold"), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12)  # y轴刻度
  )
}

plots <- lapply(unique_organisms, function(org) plot_for_organism(combined_data, org))
library(patchwork)
# 合成图表为2列 x 3行
final_plot <- (plots[[1]] | plots[[2]]) /
              (plots[[3]] | plots[[4]]) /
              (plots[[5]] | plots[[6]])

# 显示合成图表
print(final_plot)

#ggsave("D:/Desktop/Data/R/output/Organism.pdf", device = "pdf", width = 10, height = 13)
```

# Change I.perc
```{r}

# TP
combined_TP <- combined_data %>%
  filter(Variable == "TP") %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(Rank = dense_rank(Area))    

#combined_TP <- combined_TP %>%
 # left_join(select(result, Dataset, Mean_TP, TP_Range,Deviance_Explained), by = "Dataset")


ggplot(combined_TP, aes(x = log(Area), y = I.perc, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 1, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
  scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Total Phosphorus",
    fill = "Data Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )


regression_stats <- combined_TP %>%
  group_by(Data_Type) %>%
  summarise(
    model = list(lm(I.perc ~ log(Area), data = cur_data())),
    .groups = "drop"
  ) %>%
  mutate(
    r_squared = sapply(model, function(m) summary(m)$r.squared),
    p_value = sapply(model, function(m) summary(m)$coefficients[2, 4])
  )

# 为 R² 和 p 值准备标签
regression_stats <- regression_stats %>%
  mutate(label = paste0("R² = ", round(r_squared, 2), 
                        ", p = ", signif(p_value, 3)))

# 绘图
ggplot(combined_TP, aes(x = log(Area), y = I.perc, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "lm", se = TRUE, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 添加 R² 和 p 值到图中
  geom_text(
    data = regression_stats,
    aes(x = 0.5, y = 80, label = label, color = Data_Type),  # 位置和颜色根据需要调整
    inherit.aes = FALSE,
    size = 5,
    hjust = 0
  ) +
  # 自定义颜色
  scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Total Phosphorus",
    fill = "Data Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 18, hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )


# Climate
combined_Climate_sum <- combined_data %>%
  filter(Variable %in% c("AT", "AP")) %>%                # 筛选出 AT 和 AP
  arrange(Area) %>%                                      # 按 Area 从小到大排序
  mutate(Rank = dense_rank(Area)) %>%                    # 创建 Rank 列
  group_by(Data_Type, Dataset, Rank) %>%                 # 按 Data_Type、Dataset 和 Rank 分组
  summarize(
    Sum_I_perc = sum(I.perc, na.rm = TRUE),              # 计算 AT 和 AP 的 I.perc 之和
    Area = mean(Area, na.rm = TRUE),                # 计算 Area 的均值
    Num = mean(Num, na.rm = TRUE),                  # 计算 Num 的均值
    .groups = "drop"
  )


ggplot(combined_Climate_sum, aes(x =log(Num / Area), y = Sum_I_perc, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Climate",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )



# Latitude
combined_AL <- combined_data %>%
  filter(Variable == c("AL")) %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(Rank = dense_rank(Area))    




ggplot(combined_AL, aes(x = Rank, y = I.perc, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Absolute Latitude",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )


# Elevation
combined_Elevation <- combined_data %>%
  filter(Variable == "Elevation") %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(Rank = dense_rank(Area))    




ggplot(combined_Elevation, aes(x = Rank, y = I.perc, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Elevation",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )



# Interaction
combined_Interaction_sum <- combined_data %>%
  filter(Variable %in% c("TP.AT", "TP.AP")) %>%                # 筛选出 AT 和 AP
  arrange(Area) %>%                                      # 按 Area 从小到大排序
  mutate(Rank = dense_rank(Area)) %>%                    # 创建 Rank 列
  group_by(Data_Type, Dataset, Rank) %>%                 # 按 Data_Type、Dataset 和 Rank 分组
  summarize(
    Sum_I_perc = sum(I.perc, na.rm = TRUE),              # 计算 AT 和 AP 的 I.perc 之和
    .groups = "drop"
  )
   

ggplot(combined_Interaction_sum, aes(x = Rank, y = Sum_I_perc, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Interaction variable",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )

```

# Change I.perc sig and ns
```{r}
combined_TP <- combined_data %>%
  filter(Variable == "TP") %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(
    Rank = dense_rank(Area),                      # 计算 Rank
    Significance = ifelse(Pr.t < 0.05, "Significant", "Not Significant") # 判断显著性
  )

# 绘图
ggplot(combined_TP, aes(x = Rank, y = I.perc, color = Data_Type)) +
  # 添加散点，根据显著性分形状
  geom_point(aes(shape = Significance), size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间，分别拟合不同 Data_Type
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2) +
  # 自定义颜色
  scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 自定义点的形状
  scale_shape_manual(
    values = c("Significant" = 16, "Not Significant" = 1), # 实心圆和空心圆
    name = "Significance"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Total Phosphorus by Data Type",
    fill = "Data Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 18, hjust = 0.5), # 标题居中
    axis.title.x = element_text(size = 14),           # x轴标题
    axis.title.y = element_text(size = 14),           # y轴标题
    axis.text.x = element_text(size = 12),            # x轴刻度
    axis.text.y = element_text(size = 12),            # y轴刻度
    legend.position = "bottom",                       # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(),                     # 去除网格线
    panel.border = element_blank()                    # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )




```

# Change Individual
```{r}
# TP
combined_TP <- combined_data %>%
  filter(Variable == "TP") %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(Rank = dense_rank(Area))    

ggplot(combined_TP, aes(x = Rank, y = Individual, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
  scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Total Phosphorus",
    fill = "Data Type"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )


# Climate
combined_Climate_sum <- combined_data %>%
  filter(Variable %in% c("AT", "AP")) %>%                # 筛选出 AT 和 AP
  arrange(Area) %>%                                      # 按 Area 从小到大排序
  mutate(Rank = dense_rank(Area)) %>%                    # 创建 Rank 列
  group_by(Data_Type, Dataset, Rank) %>%                 # 按 Data_Type、Dataset 和 Rank 分组
  summarize(
    Sum_Individual = sum(Individual, na.rm = TRUE),              # 计算 AT 和 AP 的 Individual 之和
    .groups = "drop"
  )


ggplot(combined_Climate_sum, aes(x = Rank, y = Sum_Individual, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Climate",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )


# Latitude
combined_AL <- combined_data %>%
  filter(Variable == c("AL")) %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(Rank = dense_rank(Area))    

ggplot(combined_AL, aes(x = Rank, y = Individual, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Absolute Latitude",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )


# Elevation
combined_Elevation <- combined_data %>%
  filter(Variable == "Elevation") %>%                     # 筛选 Variable 为 TP 的数据
  arrange(Area) %>%                                # 按 Area 从小到大排序
  distinct(Dataset, Data_Type, .keep_all = TRUE) %>% # 保留每个 Dataset 和 Data_Type 的唯一组合
  mutate(Rank = dense_rank(Area))    

ggplot(combined_Elevation, aes(x = Rank, y = Individual, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Elevation",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )



# Interaction
combined_Interaction_sum <- combined_data %>%
  filter(Variable %in% c("TP.AT", "TP.AP")) %>%                # 筛选出 AT 和 AP
  arrange(Area) %>%                                      # 按 Area 从小到大排序
  mutate(Rank = dense_rank(Area)) %>%                    # 创建 Rank 列
  group_by(Data_Type, Dataset, Rank) %>%                 # 按 Data_Type、Dataset 和 Rank 分组
  summarize(
    Sum_Individual = sum(Individual, na.rm = TRUE),              # 计算 AT 和 AP 的 I.perc 之和
    .groups = "drop"
  )
   

ggplot(combined_Interaction_sum, aes(x = Rank, y = Sum_Individual, color = Data_Type)) +
  # 添加散点
  geom_point(size = 3, alpha = 0.7) +
  # 添加拟合线和置信区间
  geom_smooth(method = "loess", se = TRUE, span = 0.8, size = 1, alpha = 0.2, aes(fill = Data_Type)) +
  # 自定义颜色
   scale_color_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  scale_fill_manual(
    values = c("Richness" = "#547ac0", "FRic" = "#FF8C00"),
    name = "Data Type"
  ) +
  # 图形设置
  labs(
    x = "Rank by Area",
    y = "Hierarchical Partitioning Importance (%)",
    title = "Relative Importance of Interaction variable",
    fill = "Data Type"
  ) +
  theme_minimal() +
   theme(
    plot.title = element_text(size = 18,  hjust = 0.1), # 标题
    axis.title.x = element_text(size = 14), # x轴标题
    axis.title.y = element_text(size = 14), # y轴标题
    axis.text.x = element_text(size = 12), # x轴刻度
    axis.text.y = element_text(size = 12), # y轴刻度
    legend.position = "bottom", # 图例位置
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    panel.grid = element_blank(), # 去除网格线
    panel.border = element_blank() # 去除默认边框
  ) +
  theme(
    axis.line.x = element_line(color = "black", size = 0.8), # 添加下边框
    axis.line.y = element_line(color = "black", size = 0.8)  # 添加左边框
  )

```

# GLMM_Relative_Richness different scale
```{r}
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换
library(geosphere)
library(lmerTest)

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data %>%
  filter(!is.na(TP), 
         !is.na(AT), 
         !is.na(AP))


data <- data %>%
  mutate(across(c(TP,TP2,AT,AP,TP.AP,TP.AT,TP2.AT,TP2.AP,Area,TP.Area,TP2.Area), ~ as.numeric(scale(.))))


  glm_model <- glm(
  Relative_Richness ~ TP + TP2 + AT + AP + TP.AP + TP.AT + TP2.AT + TP2.AP + Area + TP.Area + TP2.Area,
  data = data,
  family = gaussian()
)

    glmm_model <- lmer(Relative_Richness ~ TP + TP2 + AT + AP + TP.AP + TP.AT + TP2.AT + TP2.AP + Area + TP.Area + TP2.Area + (1 | Organism), 
                   data = data)
aic_glm <- AIC(glm_model)
aic_glmm <- AIC(glmm_model)

cat("AIC of GLM:", aic_glm, "\n")
cat("AIC of GLMM:", aic_glmm, "\n")

    
results <- list()  
scales <- c("local", "region", "continent")

# 遍历每个 Scale 分类
for (scale in scales) {
  
  # 提取对应 Scale 的子集
  subset_data <- data[which(data$Scale == scale), ]
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLMM 模型，使用子集数据而不是完整数据集
    lmer_model <- lmer(Relative_Richness ~ TP + AT + TP:AT + AP + TP:AP + (1 | Organism.x), 
                       data = subset_data)
    
    # 提取 GLMM 模型的系数和统计信息
    summary_model <- summary(lmer_model)
    glmm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glmm_coefficients_df <- glmm_coefficients_df %>%
    dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)
    glmm_coefficients_df <- cbind(Variable = rownames(glmm_coefficients_df), glmm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(lmer_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      if (length(hierarchical_partitioning) < nrow(glmm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glmm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      hierarchical_partitioning <- rep(NA, nrow(glmm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Scale = scale
    )
    
    # 重复 temp_df 的行数以匹配 glmm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glmm_coefficients_df)), ]
    
    # 创建 Hierarchical_Partitioning 数据框，并处理缺失行的情况
    Hierarchical_Partitioning <- data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
    colnames(empty_row) <- colnames(Hierarchical_Partitioning)
    Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    
    # 将 glmm 系数和分解结果添加到表格中
    glmm_results_expanded <- cbind(
      temp_df,
      glmm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[scale]] <- glmm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

print(final_result)










if (nrow(data) > 1) {
  
  # 拟合 GLMM 模型
  lmer_model <- lmer(Relative_Richness ~ TP + TP2 + AT + AP + TP.AP + TP.AT + TP2.AT + TP2.AP + Area + TP.Area + TP2.Area + (1 | Organism), 
                   data = data)
  
  # 提取 GLMM 模型的系数和统计信息
  summary_model <- summary(lmer_model)
  glmm_coefficients_df <- as.data.frame(summary_model$coefficients)
  glmm_coefficients_df <- glmm_coefficients_df %>%
  dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)
  glmm_coefficients_df <- cbind(Variable = rownames(glmm_coefficients_df), glmm_coefficients_df)
  
  # 使用 glmm.hp 分解因子相对重要性
  glmm_hp_results <- glmm.hp::glmm.hp(lmer_model)
  
  # 提取 hierarchical.partitioning 的值
  if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
    hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
    if (length(hierarchical_partitioning) < nrow(glmm_coefficients_df)) {
      hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glmm_coefficients_df) - length(hierarchical_partitioning)))
    }
  } else {
    hierarchical_partitioning <- rep(NA, nrow(glmm_coefficients_df))
  }
  
  # 创建结果数据框
  Hierarchical_Partitioning <- data.frame(hierarchical_partitioning)
  empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
  colnames(empty_row) <- colnames(Hierarchical_Partitioning)
  Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
  
  final_result <- cbind(
    glmm_coefficients_df,
    Hierarchical_Partitioning = Hierarchical_Partitioning
  )
}

# 打印最终结果
print(final_result)

#write.csv(final_result,file = "D:/Desktop/Data/R/output/glmm_Relative_Richness_Scale.csv")
```

# GLMM_Relative_FRic different scale
```{r}
#TEST=final_result[,c(1,2,9)]
#TEST2=final_result[,c(1,2,9)]
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换
library(geosphere)
library(lmerTest)

data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data[!is.na(data$FRic), ]
data$Relative_FRic <- data$FRic / ave(data$FRic, data$Dataset, FUN = max)
data <- data %>%
  filter(!is.na(TP), 
         !is.na(AT), 
         !is.na(AP))

merged_data <- merge(data, result, by = "Dataset", all.x = TRUE)
data <- merged_data %>%
  mutate(Scale = case_when(
    Max_Distance_km < 200 ~ "local",
    Max_Distance_km >= 200 & Max_Distance_km <= 2000 ~ "region",
    Max_Distance_km > 2000 ~ "continent"
  ))

data <- data %>%
  mutate(across(c(TP, pH,TP.pH, AT, AP, TP.AT, TP.AP), ~ as.numeric(scale(.))))

scales <- unique(data$Scale)


    glm_model <- glm(Relative_FRic ~ TP + AT + TP.AT + AP + TP.AP, 
                     data = data, 
                     family = gaussian())
    glmm_model <- lmer(Relative_FRic ~ TP + AT + TP:AT + AP + TP:AP + (1 | Organism), 
                   data = data)
aic_glm <- AIC(glm_model)
aic_glmm <- AIC(glmm_model)

cat("AIC of GLM:", aic_glm, "\n")
cat("AIC of GLMM:", aic_glmm, "\n")

    
    glmm_hp_results <- glmm.hp::glmm.hp(glmm_model)
    
results <- list()  
scales <- c("local", "region", "continent")

# 遍历每个 Scale 分类
for (scale in scales) {
  
  # 提取对应 Scale 的子集
  subset_data <- data[which(data$Scale == scale), ]
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLMM 模型，使用子集数据而不是完整数据集
    lmer_model <- lmer(Relative_FRic ~ TP + AT + TP:AT + AP + TP:AP + (1 | Organism.x), 
                       data = subset_data)
    
    # 提取 GLMM 模型的系数和统计信息
    summary_model <- summary(lmer_model)
    glmm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glmm_coefficients_df <- glmm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)
    glmm_coefficients_df <- cbind(Variable = rownames(glmm_coefficients_df), glmm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(lmer_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      if (length(hierarchical_partitioning) < nrow(glmm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glmm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      hierarchical_partitioning <- rep(NA, nrow(glmm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Scale = scale
    )
    
    # 重复 temp_df 的行数以匹配 glmm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glmm_coefficients_df)), ]
    
    # 创建 Hierarchical_Partitioning 数据框，并处理缺失行的情况
    Hierarchical_Partitioning <- data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
    colnames(empty_row) <- colnames(Hierarchical_Partitioning)
    Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    
    # 将 glmm 系数和分解结果添加到表格中
    glmm_results_expanded <- cbind(
      temp_df,
      glmm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[scale]] <- glmm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)

print(final_result)

#write.csv(final_result,file = "D:/Desktop/Data/R/output/glmm_Relative_FRic_Scale.csv")
```

# GLM_Relative_FRic different scale
```{r}
library(lme4)
library(glmm.hp)
library(dplyr)
library(broom) 
library(tidyr) # 用于数据转换
library(geosphere)
data=read.csv("D:/Desktop/Data/R/output/All_data.csv")
data <- data[!is.na(data$FRic), ]
data$Relative_FRic <- data$FRic / ave(data$FRic, data$Dataset, FUN = max)
data <- data %>%
  filter(!is.na(TP),
         !is.na(AT), 
         !is.na(AP))

merged_data <- merge(data, result, by = "Dataset", all.x = TRUE)
data <- merged_data %>%
  mutate(Scale = case_when(
    Max_Distance_km < 200 ~ "local",
    Max_Distance_km >= 200 & Max_Distance_km <= 2000 ~ "region",
    Max_Distance_km > 2000 ~ "continent"
  ))

data <- data %>%
  mutate(across(c(TP, AT, AP, TP.AT, TP.AP), ~ as.numeric(scale(.))))

scales <- unique(data$Scale)


    glm_model <- glm(Relative_FRic ~ TP + AT + TP.AT + AP + TP.AP, 
                     data = data, 
                     family = gaussian())
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
results <- list()  
scales <- c("local", "region", "continent")

# 遍历每个 Scale 分类
for (scale in scales) {
  
  # 提取对应 Scale 的子集
  subset_data <- data[which(data$Scale == scale), ]
  
  # 检查是否有足够的行数来进行分析
  if (nrow(subset_data) > 1) {
    
    # 拟合 GLM 模型
    glm_model <- glm(Relative_FRic ~ TP + AT + TP.AT + AP + TP.AP, 
                     data = subset_data, 
                     family = gaussian())
    
    # 提取 GLM 模型的系数和统计信息
    summary_model <- summary(glm_model)
    glm_coefficients_df <- as.data.frame(summary_model$coefficients)
    glm_coefficients_df <- glm_coefficients_df %>%
      dplyr::select(Estimate, `Std. Error`, `Pr(>|t|)`)
    glm_coefficients_df <- cbind(Variable = rownames(glm_coefficients_df), glm_coefficients_df)
    
    # 使用 glmm.hp 分解因子相对重要性
    glmm_hp_results <- glmm.hp::glmm.hp(glm_model)
    
    # 提取 hierarchical.partitioning 的值并确保行数一致
    if (!is.null(glmm_hp_results$hierarchical.partitioning)) {
      hierarchical_partitioning <- glmm_hp_results$hierarchical.partitioning
      if (length(hierarchical_partitioning) < nrow(glm_coefficients_df)) {
        hierarchical_partitioning <- c(hierarchical_partitioning, rep(NA, nrow(glm_coefficients_df) - length(hierarchical_partitioning)))
      }
    } else {
      hierarchical_partitioning <- rep(NA, nrow(glm_coefficients_df))
    }
    
    # 创建结果数据框
    temp_df <- data.frame(
      Scale = scale
    )
    
    # 重复 temp_df 的行数以匹配 glm_coefficients_df 的行数
    temp_df <- temp_df[rep(1, nrow(glm_coefficients_df)), ]
    
    # 创建 Hierarchical_Partitioning 数据框，并处理缺失行的情况
    Hierarchical_Partitioning <- data.frame(hierarchical_partitioning)
    empty_row <- as.data.frame(matrix(NA, nrow = 1, ncol = ncol(Hierarchical_Partitioning)))
    colnames(empty_row) <- colnames(Hierarchical_Partitioning)
    Hierarchical_Partitioning <- rbind(empty_row, Hierarchical_Partitioning)
    
    # 将 GLM 系数和分解结果添加到表格中
    glm_results_expanded <- cbind(
      temp_df,
      glm_coefficients_df,
      Hierarchical_Partitioning = Hierarchical_Partitioning
    )
    
    # 将每个临时数据框存入结果列表
    results[[scale]] <- glm_results_expanded
  }
}

# 将所有结果合并成一个数据框
final_result <- do.call(rbind, results)    

print(final_result)


write.csv(final_result,file = "D:/Desktop/Data/R/output/glm_Relative_FRic_Scale.csv")
```

#Plot GLM P_richness_fric_Scale
```{r}
library(ggplot2)
library(dplyr)
library(cowplot)
library(gridExtra)
data=read.csv("D:/Desktop/Data/R/output/glm_Relative_Richness_Scale.csv", fileEncoding = "GB18030")

data$Significance <- ifelse(data$P <= 0.001, "***",
                            ifelse(data$P <= 0.01, "**",
                                   ifelse(data$P <= 0.05, "*", "")))
data$temp_df <- factor(data$temp_df, levels = c("local", "region", "continent"))

data$Variable <- factor(data$Variable, levels = c("β5: TP*AP", "β4: TP*AT","β3: AP", "β2: AT",  "β1: TP"))
color_scheme_p1 <- c("continent" = "#fdc58f","region" = "#99cbeb", "local" = "#ea9c9d")
color_scheme_p2 <- c("continent" = "#fdc58f","region" = "#99cbeb", "local" = "#ea9c9d")

data$temp_df <- factor(data$temp_df, levels = c("local", "region", "continent"))

# 更新 p1 图：标准化回归系数的点图
p1 <- ggplot(data, aes(y = Variable, x = Estimate, color = temp_df)) +
  geom_point(position = position_dodge(width = 0.6), size = 2) +
  geom_errorbar(aes(xmin = Estimate - `Std..Error`, xmax = Estimate + `Std..Error`),
                width = 0, position = position_dodge(width = 0.6)) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.8) +
  # 添加显著性标记
  geom_text(aes(label = Significance),
            position = position_dodge(width = 0.6),
            hjust = -0.5, size = 4) +
  labs(x = "Standardized coefficients", y = NULL, color = "Spatial scale") +
  scale_color_manual(values = c("local" = "#ea9c9d", "region" = "#99cbeb", "continent" = "#fdc58f")) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),
    legend.position = c(0.01, 0.01),
    legend.justification = c("left", "bottom"),
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  )

# 更新 p2 图：Relative importance 的柱状图
p2 <- ggplot(data, aes(y = Variable, x = Importance, fill = temp_df)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.75), width = 0.6) +
  labs(title = "", x = "Relative importance (%)", y = NULL, fill = "Spatial scale") +
  scale_fill_manual(values = c("local" = "#ea9c9d", "region" = "#99cbeb", "continent" = "#fdc58f")) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    legend.position = c(1, 0.01),
    legend.justification = c("right", "bottom"),
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  )

# 使用 cowplot 包将两个图并排显示
combined_plot <- plot_grid(p1, p2, align = "h", axis = "tb", ncol = 2, rel_widths = c(1, 1))

# 显示图形
print(combined_plot)

ggsave("D:/Desktop/Data/R/output/Scale.pdf", device = "pdf", width = 6, height = 4)
```

#Plot GLM P_richness_fric_Scale
```{r}
library(ggplot2)
library(cowplot)
library(ggpattern)

library(ggplot2)
library(cowplot)

# 读取 CSV 文件
data_richness <- read.csv("D:/Desktop/Data/R/output/glm_Relative_Richness_Scale.csv", fileEncoding = "GB18030")
data_FRic <- read.csv("D:/Desktop/Data/R/output/glm_Relative_FRic_Scale.csv", fileEncoding = "GB18030")

# 添加 Significance 列
data_richness$Significance <- ifelse(data_richness$P <= 0.001, "***",
                                     ifelse(data_richness$P <= 0.01, "**",
                                            ifelse(data_richness$P <= 0.05, "*", "")))

data_FRic$Significance <- ifelse(data_FRic$P <= 0.001, "***",
                                 ifelse(data_FRic$P <= 0.01, "**",
                                        ifelse(data_FRic$P <= 0.05, "*", "")))

# 添加 Response 列
data_richness$Response <- "Richness"
data_FRic$Response <- "FRic"

# 合并数据框
data <- rbind(data_richness, data_FRic)

# 设置因子顺序
data$temp_df <- factor(data$temp_df, levels = c("continent","region","local"))
data$Variable <- factor(data$Variable, levels = c("β5: TP*AP", "β4: TP*AT", "β3: AP", "β2: AT", "β1: TP"))

# 定义颜色方案
color_scheme <- c("continent" = "#fdc58f", "region" = "#99cbeb", "local" = "#ea9c9d")

# 使用 position_dodge() 避免分离现象
dodge <- position_dodge(width = 0.6)

# 左图：标准化回归系数的点图，统一使用实线误差条，仅使用形状区分
p1 <- ggplot(data, aes(y = Variable, x = Estimate, color = temp_df, shape = Response)) +
  geom_point(position = dodge, size = 2) +
  geom_errorbar(aes(xmin = Estimate - `Std..Error`, xmax = Estimate + `Std..Error`),
                width = 0, position = dodge, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.8) +
  geom_text(aes(label = Significance),
            position = dodge,
            hjust = -0.5, size = 4) +
  labs(x = "Standardized coefficients", y = NULL, color = "Spatial scale", shape = "Response") +
  scale_color_manual(values = color_scheme) +
  scale_shape_manual(values = c("Richness" = 16, "FRic" = 17)) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    legend.box = "horizontal",
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  )

# 右图保持不变
library(ggpattern)

p2 <- ggplot(data, aes(y = Variable, x = Importance, fill = temp_df, pattern = Response)) +
  # 绘制 Richness 的柱子（实心填充）
  geom_bar_pattern(
    stat = "identity",
    position = position_dodge(width = 0.75),
    width = 0.6,
    pattern_density = 0.1,
    pattern_angle = 45,
    pattern_spacing = 0.05,
    pattern_fill = "white",      # 设置虚线的颜色
    pattern_color = "white"      # 设置虚线的颜色
  ) +
  scale_fill_manual(values = color_scheme) +
  scale_pattern_manual(values = c("Richness" = "none", "FRic" = "stripe")) +
  labs(x = "Relative importance (%)", y = NULL, fill = "Spatial scale", pattern = "Response") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    legend.position = "bottom",
    legend.box = "horizontal",
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  )

# 使用 cowplot 包将两个图并排显示
combined_plot <- plot_grid(p1, p2, align = "h", axis = "tb", ncol = 2, rel_widths = c(1, 1))

# 显示图形
print(combined_plot)



ggsave("D:/Desktop/Data/R/output/Scale02.pdf", device = "pdf", width = 7, height = 5)
```

#Plot GLMM P_richness_fric_Scale
```{r}
library(ggplot2)
library(cowplot)
library(ggpattern)

library(ggplot2)
library(cowplot)

# 读取 CSV 文件
data_richness <- read.csv("D:/Desktop/Data/R/output/glmm_Relative_Richness_Scale.csv", fileEncoding = "GB18030")
data_FRic <- read.csv("D:/Desktop/Data/R/output/glmm_Relative_FRic_Scale.csv", fileEncoding = "GB18030")

# 添加 Significance 列
data_richness$Significance <- ifelse(data_richness$P <= 0.001, "***",
                                     ifelse(data_richness$P <= 0.01, "**",
                                            ifelse(data_richness$P <= 0.05, "*", "")))

data_FRic$Significance <- ifelse(data_FRic$P <= 0.001, "***",
                                 ifelse(data_FRic$P <= 0.01, "**",
                                        ifelse(data_FRic$P <= 0.05, "*", "")))

# 添加 Response 列
data_richness$Response <- "Richness"
data_FRic$Response <- "FRic"

# 合并数据框
data <- rbind(data_richness, data_FRic)

# 设置因子顺序
data$temp_df <- factor(data$temp_df, levels = c("continent","region","local"))
data$Variable <- factor(data$Variable, levels = c("β5: TP*AP", "β4: TP*AT", "β3: AP", "β2: AT", "β1: TP"))

# 定义颜色方案
color_scheme <- c("continent" = "#fdc58f", "region" = "#99cbeb", "local" = "#ea9c9d")

# 使用 position_dodge() 避免分离现象
dodge <- position_dodge(width = 0.6)

# 左图：标准化回归系数的点图，统一使用实线误差条，仅使用形状区分
p1 <- ggplot(data, aes(y = Variable, x = Estimate, color = temp_df, shape = Response)) +
  geom_point(position = dodge, size = 2) +
  geom_errorbar(aes(xmin = Estimate - `Std..Error`, xmax = Estimate + `Std..Error`),
                width = 0, position = dodge, linetype = "solid") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.8) +
  geom_text(aes(label = Significance),
            position = dodge,
            hjust = -0.5, size = 4) +
  labs(x = "Standardized coefficients", y = NULL, color = "Spatial scale", shape = "Response") +
  scale_color_manual(values = color_scheme) +
  scale_shape_manual(values = c("Richness" = 16, "FRic" = 17)) +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 10),
    legend.position = "bottom",
    legend.box = "horizontal",
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  )

# 右图保持不变
library(ggpattern)

p2 <- ggplot(data, aes(y = Variable, x = Importance, fill = temp_df, pattern = Response)) +
  # 绘制 Richness 的柱子（实心填充）
  geom_bar_pattern(
    stat = "identity",
    position = position_dodge(width = 0.75),
    width = 0.6,
    pattern_density = 0.1,
    pattern_angle = 45,
    pattern_spacing = 0.05,
    pattern_fill = "white",      # 设置虚线的颜色
    pattern_color = "white"      # 设置虚线的颜色
  ) +
  scale_fill_manual(values = color_scheme) +
  scale_pattern_manual(values = c("Richness" = "none", "FRic" = "stripe")) +
  labs(x = "Relative importance (%)", y = NULL, fill = "Spatial scale", pattern = "Response") +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    legend.position = "bottom",
    legend.box = "horizontal",
    panel.grid = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, size = 1)
  )

# 使用 cowplot 包将两个图并排显示
combined_plot <- plot_grid(p1, p2, align = "h", axis = "tb", ncol = 2, rel_widths = c(1, 1))

# 显示图形
print(combined_plot)



ggsave("D:/Desktop/Data/R/output/Scale03glmm.pdf", device = "pdf", width = 7, height = 5)
```


# Test
```{r}
mod_productivity <- lm(Productivity ~ Elevation + Latitude + AT + AP, data = data_sem)

# 构建四种类型的 logit 模型（受四个环境因子 和 生产力 共同影响）
mod_neglinear <- glm(Diversity_NegLinear ~ Elevation + Latitude + AT + AP + Productivity,
                     family = binomial(link = "logit"), data = data_sem)

mod_unimodal <- glm(Diversity_Unimodal ~ Elevation + Latitude + AT + AP + Productivity,
                    family = binomial(link = "logit"), data = data_sem)

mod_poslinear <- glm(Diversity_PosLinear ~ Elevation + Latitude + AT + AP + Productivity,
                     family = binomial(link = "logit"), data = data_sem)

mod_nonsignificant <- glm(Diversity_NonSignificant ~ Elevation + Latitude + AT + AP + Productivity,
                          family = binomial(link = "logit"), data = data_sem)

# 构建 psem 模型
sem_model <- psem(
  mod_productivity,
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)

# 查看模型结构和路径显著性
summary(sem_model)

plot(sem_model)






library(nnet)

data$Relationship_Type <- relevel(factor(data$Relationship_Type), ref = "Non-significant")

mod <- multinom(Relationship_Type ~ Median_AT + AT_Range + Median_AP + AP_Range + 
                                      Median_Elevation + Elevation_Range + 
                                      Median_AL + AL_Range, data = data)
summary(mod)


z <- summary(mod)$coefficients / summary(mod)$standard.errors
p <- (1 - pnorm(abs(z))) * 2
round(p, 4)

library(reshape2)
p_melt <- melt(p)
colnames(p_melt) <- c("Relationship_Type", "Variable", "p_value")

ggplot(p_melt, aes(x = Variable, y = Relationship_Type, fill = p_value)) +
  geom_tile(color = "white") +
  scale_fill_gradientn(colors = c("red", "orange", "white"), 
                       values = scales::rescale(c(0, 0.05, 1)),
                       name = "p-value") +
  geom_text(aes(label = round(p_value, 3)), size = 3) +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Significance of Predictors for Relationship Types",
       x = "Environmental Variables", y = "Relationship Type")





coef_mat <- summary(mod)$coefficients
se_mat <- summary(mod)$standard.errors
z_mat <- coef_mat / se_mat
p_mat <- (1 - pnorm(abs(z_mat))) * 2

# 将系数矩阵和 p 值转为长格式
coef_long <- melt(coef_mat)
colnames(coef_long) <- c("Relationship_Type", "Variable", "Coefficient")

p_long <- melt(p_mat)
colnames(p_long) <- c("Relationship_Type", "Variable", "p_value")

# 合并
plot_data <- left_join(coef_long, p_long, by = c("Relationship_Type", "Variable"))

plot_data <- plot_data %>%
  mutate(Signif = case_when(
    p_value < 0.001 ~ "***",
    p_value < 0.01  ~ "**",
    p_value < 0.05  ~ "*",
    p_value < 0.1   ~ ".",
    TRUE ~ ""
  ))

# 可视化热图
ggplot(plot_data, aes(x = Variable, y = Relationship_Type, fill = Coefficient)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "firebrick", mid = "white", high = "steelblue",
                       midpoint = 0, name = "Coefficient") +
  geom_text(aes(label = Signif), size = 5, color = "black") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.grid = element_blank()) +
  labs(title = "Effect of Environmental Factors on Relationship Types",
       subtitle = "Colors show coefficient direction and strength; stars show significance",
       x = "Environmental Variables", y = "Relationship Type")




vars <- data[, c("Median_AT", "AT_Range", "Median_AP", "AP_Range",
                 "Median_Elevation", "Elevation_Range", "Median_AL", "AL_Range","Area")]

cor_matrix <- cor(vars, use = "complete.obs")
round(cor_matrix, 2)



data$Is_Unimodal <- ifelse(data$Relationship_Type == "Positive Linear", 1, 0)

glm_unimodal <- glm(Is_Unimodal ~ Median_AT + AT_Range + Median_AP + AP_Range + 
                                   Median_Elevation + Elevation_Range + 
                                   Median_AL + AL_Range,
                    data = data, family = binomial)
summary(glm_unimodal)


data$Is_NegLinear <- ifelse(data$Relationship_Type == "Negative Linear", 1, 0)
data$Is_PosLinear <- ifelse(data$Relationship_Type == "Positive Linear", 1, 0)
data$Is_NonSig     <- ifelse(data$Relationship_Type == "Non-significant", 1, 0)









library(MuMIn)
library(broom)
library(dplyr)

# 确保 NA 会报错而不是默默忽略
options(na.action = "na.fail")

# 准备解释变量名称
predictors <- c("Median_AT", "AT_Range", "Median_AP", "AP_Range",
                "Median_Elevation", "Elevation_Range", "Median_AL", "AL_Range")

# 准备响应变量（每一类转换为 0/1）
relationship_types <- unique(data$Relationship_Type)

# 用来保存所有模型选择结果
all_results <- list()

# 循环每一个关系类型，构建独立模型 + dredge
for (rtype in relationship_types) {
  # 创建二分类响应变量
  data[[paste0("is_", gsub(" ", "_", rtype))]] <- ifelse(data$Relationship_Type == rtype, 1, 0)

  # 构建公式
  response_var <- paste0("is_", gsub(" ", "_", rtype))
  form <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))

  # 构建 full model
  glm_full <- glm(form, data = data, family = binomial)

  # 模型选择（自动子集模型 + AICc）
  model_set <- dredge(glm_full, rank = "AICc", trace = FALSE)

  # 提取前几名模型（比如 ΔAICc < 4 的）
  top_models <- get.models(model_set, subset = delta < 4)

  # 提取信息
  model_summaries <- lapply(top_models, function(mod) {
    coefs <- coef(mod)
    tidy_mod <- tidy(mod)
    r2 <- 1 - mod$deviance / mod$null.deviance  # 伪R²
    data.frame(Model = paste0("GLM_", rtype),
               Variables = paste(names(coefs)[-1], collapse = ", "),
               AICc = AICc(mod),
               R2 = round(r2, 3),
               row.names = NULL)
  })

  all_results[[rtype]] <- do.call(rbind, model_summaries)
}

# 合并所有结果
final_table <- bind_rows(all_results)

# 查看前几行
print(head(final_table))






sanitize_name <- function(x) gsub("[^a-zA-Z0-9]", "_", x)

for (rtype in relationship_types) {
  safe_rtype <- sanitize_name(rtype)
  response_var <- paste0("is_", safe_rtype)

  # 创建二分类响应变量
  data[[response_var]] <- ifelse(data$Relationship_Type == rtype, 1, 0)

  # 构建公式
  form <- as.formula(paste(response_var, "~", paste(predictors, collapse = " + ")))

  # 拟合 full model
  glm_full <- glm(form, data = data, family = binomial)

  # 模型选择
  model_set <- dredge(glm_full, rank = "AICc", trace = FALSE)

  # 提取ΔAIC < 4的模型
  top_models <- get.models(model_set, subset = delta < 4)

  # 提取结果
  model_summaries <- lapply(top_models, function(mod) {
    coefs <- coef(mod)
    tidy_mod <- tidy(mod)
    r2 <- 1 - mod$deviance / mod$null.deviance
    data.frame(Model = paste0("GLM_", rtype),
               Variables = paste(names(coefs)[-1], collapse = ", "),
               AICc = AICc(mod),
               R2 = round(r2, 3),
               row.names = NULL)
  })

  all_results[[rtype]] <- do.call(rbind, model_summaries)
}


```

# Bar plot richness
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(patchwork)
library(ggpattern)

data=read.csv("D:/Desktop/Data/R/output/bar_plot2.csv")

rich_data <- data %>%
  filter(BPR.type == "Richness") %>%
  select(Organism, 
         "Positive", "Unimodal", "Negative", 
         "None", "U_shape", Number) %>%
  mutate(across(where(is.character), ~ gsub("%", "", .))) %>%
  mutate(across(c("Positive", "Unimodal", "Negative", 
                  "None", "U_shape"), as.numeric)) %>%
  pivot_longer(cols = c("Positive", "Unimodal", "Negative", 
                        "None", "U_shape"),
               names_to = "BPR_Type", values_to = "Percentage")

rich_data$BPR_Type <- factor(rich_data$BPR_Type, 
                             levels = c("Unimodal", "Positive", "Negative", "U_shape", "None"))


bpr_colors <- c(
  "Unimodal" = "#db6968",
  "Positive" = "#0074b3",
  "Negative" = "skyblue",
  "U_shape"  = "#f8984e",
  "None"     = "gray"
)

make_group_plot <- function(df, group_label, n_label, custom_fill = FALSE) {
  p <- ggplot(df, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
    geom_bar(stat = "identity", width = 0.6) +
    annotate("text", x = 1.85, y = 58, 
             label = n_label, hjust = 1, size = 4.5) +
    scale_y_continuous(labels = percent_format(scale = 1),
                       limits = c(0, 60),
                       expand = c(0, 0)) +
    labs(title = group_label, x = NULL, y = NULL) +
    theme_minimal(base_size = 13) +
    theme(
      panel.grid = element_blank(),
      axis.line.x = element_line(color = "black", linewidth = 0.6),
      axis.line.y = element_line(color = "black", linewidth = 0.6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none",
      plot.title = element_text(hjust = 0.5)
    )
  
  # 如果需要自定义颜色
  if (custom_fill) {
    p <- p + scale_fill_manual(values = bpr_colors)
  }

  return(p)
}


# 图 1：Total
p1_data <- filter(rich_data, Organism == "Total")
p1 <- make_group_plot(p1_data, "Total", paste0("n = ", unique(p1_data$Number)), custom_fill = TRUE)

# 图 2：Lake & River
n_labels_p2 <- rich_data %>%
  filter(Organism %in% c("Lake", "River")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",  # 放在最左边的 BPR 类型
         y = 58)  

p2_data <- filter(rich_data, Organism %in% c("Lake", "River"))
p2 <- ggplot(p2_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p2, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Lake            River", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

# 图 3：Producer vs Consumer
n_labels_p3 <- rich_data %>%
  filter(Organism %in% c("Producer", "Consumer")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",
         y = 58)


p3_data <- filter(rich_data, Organism %in% c("Producer", "Consumer"))
p3 <- ggplot(p3_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p3, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Producer   Consumer", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

(p1 | p3 | p2) + plot_layout(ncol = 3)


ggsave("D:/Desktop/Data/R/output/richness.pdf",  device = "pdf", width = 9, height = 3.5)
```

# Bar plot FRic
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(patchwork)
library(ggpattern)

data=read.csv("D:/Desktop/Data/R/output/bar_plot2.csv")

rich_data <- data %>%
  filter(BPR.type == "FRic") %>%
  select(Organism, 
         "Positive", "Unimodal", "Negative", 
         "None", "U_shape", Number) %>%
  mutate(across(where(is.character), ~ gsub("%", "", .))) %>%
  mutate(across(c("Positive", "Unimodal", "Negative", 
                  "None", "U_shape"), as.numeric)) %>%
  pivot_longer(cols = c("Positive", "Unimodal", "Negative", 
                        "None", "U_shape"),
               names_to = "BPR_Type", values_to = "Percentage")

rich_data$BPR_Type <- factor(rich_data$BPR_Type, 
                             levels = c("Unimodal", "Positive", "Negative", "U_shape", "None"))


bpr_colors <- c(
  "Unimodal" = "#db6968",
  "Positive" = "#0074b3",
  "Negative" = "skyblue",
  "U_shape"  = "#f8984e",
  "None"     = "gray"
)

make_group_plot <- function(df, group_label, n_label, custom_fill = FALSE) {
  p <- ggplot(df, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
    geom_bar(stat = "identity", width = 0.6) +
    annotate("text", x = 1.85, y = 58, 
             label = n_label, hjust = 1, size = 4.5) +
    scale_y_continuous(labels = percent_format(scale = 1),
                       limits = c(0, 60),
                       expand = c(0, 0)) +
    labs(title = group_label, x = NULL, y = NULL) +
    theme_minimal(base_size = 13) +
    theme(
      panel.grid = element_blank(),
      axis.line.x = element_line(color = "black", linewidth = 0.6),
      axis.line.y = element_line(color = "black", linewidth = 0.6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none",
      plot.title = element_text(hjust = 0.5)
    )
  
  # 如果需要自定义颜色
  if (custom_fill) {
    p <- p + scale_fill_manual(values = bpr_colors)
  }

  return(p)
}


# 图 1：Total
p1_data <- filter(rich_data, Organism == "Total")
p1 <- make_group_plot(p1_data, "Total", paste0("n = ", unique(p1_data$Number)), custom_fill = TRUE)

# 图 2：Lake & River
n_labels_p2 <- rich_data %>%
  filter(Organism %in% c("Lake", "River")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",  # 放在最左边的 BPR 类型
         y = 58)  

p2_data <- filter(rich_data, Organism %in% c("Lake", "River"))
p2 <- ggplot(p2_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p2, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Lake            River", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

# 图 3：Producer vs Consumer
n_labels_p3 <- rich_data %>%
  filter(Organism %in% c("Producer", "Consumer")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",
         y = 58)


p3_data <- filter(rich_data, Organism %in% c("Producer", "Consumer"))
p3 <- ggplot(p3_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p3, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Producer   Consumer", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

(p1 | p3 | p2) + plot_layout(ncol = 3)


ggsave("D:/Desktop/Data/R/output/FRic.pdf",  device = "pdf", width = 9, height = 3.5)
```


# Bar plot Shannon
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(patchwork)
library(ggpattern)

data=read.csv("D:/Desktop/Data/R/output/bar_plot2.csv")

rich_data <- data %>%
  filter(BPR.type == "Shannon") %>%
  select(Organism, 
         "Positive", "Unimodal", "Negative", 
         "None", "U_shape", Number) %>%
  mutate(across(where(is.character), ~ gsub("%", "", .))) %>%
  mutate(across(c("Positive", "Unimodal", "Negative", 
                  "None", "U_shape"), as.numeric)) %>%
  pivot_longer(cols = c("Positive", "Unimodal", "Negative", 
                        "None", "U_shape"),
               names_to = "BPR_Type", values_to = "Percentage")

rich_data$BPR_Type <- factor(rich_data$BPR_Type, 
                             levels = c("Unimodal", "Positive", "Negative", "U_shape", "None"))


bpr_colors <- c(
  "Unimodal" = "#db6968",
  "Positive" = "#0074b3",
  "Negative" = "skyblue",
  "U_shape"  = "#f8984e",
  "None"     = "gray"
)

make_group_plot <- function(df, group_label, n_label, custom_fill = FALSE) {
  p <- ggplot(df, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
    geom_bar(stat = "identity", width = 0.6) +
    annotate("text", x = 1.85, y = 58, 
             label = n_label, hjust = 1, size = 4.5) +
    scale_y_continuous(labels = percent_format(scale = 1),
                       limits = c(0, 60),
                       expand = c(0, 0)) +
    labs(title = group_label, x = NULL, y = NULL) +
    theme_minimal(base_size = 13) +
    theme(
      panel.grid = element_blank(),
      axis.line.x = element_line(color = "black", linewidth = 0.6),
      axis.line.y = element_line(color = "black", linewidth = 0.6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none",
      plot.title = element_text(hjust = 0.5)
    )
  
  # 如果需要自定义颜色
  if (custom_fill) {
    p <- p + scale_fill_manual(values = bpr_colors)
  }

  return(p)
}


# 图 1：Total
p1_data <- filter(rich_data, Organism == "Total")
p1 <- make_group_plot(p1_data, "Total", paste0("n = ", unique(p1_data$Number)), custom_fill = TRUE)

# 图 2：Lake & River
n_labels_p2 <- rich_data %>%
  filter(Organism %in% c("Lake", "River")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",  # 放在最左边的 BPR 类型
         y = 58)  

p2_data <- filter(rich_data, Organism %in% c("Lake", "River"))
p2 <- ggplot(p2_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p2, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Lake            River", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

# 图 3：Producer vs Consumer
n_labels_p3 <- rich_data %>%
  filter(Organism %in% c("Producer", "Consumer")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",
         y = 58)


p3_data <- filter(rich_data, Organism %in% c("Producer", "Consumer"))
p3 <- ggplot(p3_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p3, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Producer   Consumer", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

(p1 | p3 | p2) + plot_layout(ncol = 3)


ggsave("D:/Desktop/Data/R/output/Shannon.pdf",  device = "pdf", width = 9, height = 3.5)
```

# Bar plot FDis
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(scales)
library(patchwork)
library(ggpattern)

data=read.csv("D:/Desktop/Data/R/output/bar_plot2.csv")

rich_data <- data %>%
  filter(BPR.type == "FDis") %>%
  select(Organism, 
         "Positive", "Unimodal", "Negative", 
         "None", "U_shape", Number) %>%
  mutate(across(where(is.character), ~ gsub("%", "", .))) %>%
  mutate(across(c("Positive", "Unimodal", "Negative", 
                  "None", "U_shape"), as.numeric)) %>%
  pivot_longer(cols = c("Positive", "Unimodal", "Negative", 
                        "None", "U_shape"),
               names_to = "BPR_Type", values_to = "Percentage")

rich_data$BPR_Type <- factor(rich_data$BPR_Type, 
                             levels = c("Unimodal", "Positive", "Negative", "U_shape", "None"))


bpr_colors <- c(
  "Unimodal" = "#db6968",
  "Positive" = "#0074b3",
  "Negative" = "skyblue",
  "U_shape"  = "#f8984e",
  "None"     = "gray"
)

make_group_plot <- function(df, group_label, n_label, custom_fill = FALSE) {
  p <- ggplot(df, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
    geom_bar(stat = "identity", width = 0.6) +
    annotate("text", x = 1.85, y = 58, 
             label = n_label, hjust = 1, size = 4.5) +
    scale_y_continuous(labels = percent_format(scale = 1),
                       limits = c(0, 60),
                       expand = c(0, 0)) +
    labs(title = group_label, x = NULL, y = NULL) +
    theme_minimal(base_size = 13) +
    theme(
      panel.grid = element_blank(),
      axis.line.x = element_line(color = "black", linewidth = 0.6),
      axis.line.y = element_line(color = "black", linewidth = 0.6),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none",
      plot.title = element_text(hjust = 0.5)
    )
  
  # 如果需要自定义颜色
  if (custom_fill) {
    p <- p + scale_fill_manual(values = bpr_colors)
  }

  return(p)
}


# 图 1：Total
p1_data <- filter(rich_data, Organism == "Total")
p1 <- make_group_plot(p1_data, "Total", paste0("n = ", unique(p1_data$Number)), custom_fill = TRUE)

# 图 2：Lake & River
n_labels_p2 <- rich_data %>%
  filter(Organism %in% c("Lake", "River")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",  # 放在最左边的 BPR 类型
         y = 58)  

p2_data <- filter(rich_data, Organism %in% c("Lake", "River"))
p2 <- ggplot(p2_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p2, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Lake            River", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

# 图 3：Producer vs Consumer
n_labels_p3 <- rich_data %>%
  filter(Organism %in% c("Producer", "Consumer")) %>%
  select(Organism, Number) %>%
  distinct() %>%
  mutate(label = paste0("n = ", Number),
         x = "Unimodal",
         y = 58)


p3_data <- filter(rich_data, Organism %in% c("Producer", "Consumer"))
p3 <- ggplot(p3_data, aes(x = BPR_Type, y = Percentage, fill = BPR_Type)) +
  geom_bar(stat = "identity", width = 0.7) +
  facet_wrap(~ Organism) +
  geom_text(data = n_labels_p3, aes(x = x, y = y, label = label),
            inherit.aes = FALSE, hjust = 0, size = 4.5) +
  scale_fill_manual(values = bpr_colors) +
  scale_y_continuous(labels = percent_format(scale = 1), limits = c(0, 60), expand = c(0, 0)) +
  labs(title = "Producer   Consumer", x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme( legend.position = "none",
    panel.grid = element_blank(),
    axis.line = element_line(color = "black"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )

(p1 | p3 | p2) + plot_layout(ncol = 3)


ggsave("D:/Desktop/Data/R/output/FDis.pdf",  device = "pdf", width = 9, height = 3.5)
```



#SEM TD
```{r}

library(piecewiseSEM)
library(dplyr)
library(readr)
library(ggplot2)
library(ggdag)
library(stringr)
library(e1071)
library(lme4)

data=read.csv("D:/Desktop/Data/R/output/result_all.csv")


data <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD21","BD19")))
data_sem <- data %>% 
  select(Organism, Group,Data, Area, Median_TP, Median_AT, Median_AP, Median_Elevation, Median_AL, Area, Relationship_Type, TP_Range, AT_Range, AP_Range, Elevation_Range, AL_Range) %>%
  rename(
    TP = Median_TP,      # 生产力
    AT = Median_AT,                # 温度
    AP = Median_AP,                # 降水量
    Elevation = Median_Elevation,  # 海拔
    Latitude = Median_AL,          # 纬度
    Area = Area,                   # 面积
    Relationships = Relationship_Type, # 关系类型
    TP_Range = TP_Range,           # 总磷范围
    AT_Range = AT_Range,           # 温度范围
    AP_Range = AP_Range,           # 降水范围
    Elevation_Range = Elevation_Range, # 海拔范围
    AL_Range = AL_Range            # 纬度范围
  ) %>%
  mutate(
    NegLinear = ifelse(Relationships == "Negative Linear", 1, 0),
    Unimodal = ifelse(Relationships == "Unimodal", 1, 0),
    PosLinear = ifelse(Relationships == "Positive Linear", 1, 0),
    NonSignificant = ifelse(Relationships == "Non-significant", 1, 0) # 添加 Non-significant
  ) %>%
  select(-Relationships)  # 删除原始 Relationships 列

data_sem$Group <- as.factor(data_sem$Group)
data_sem$Data <- as.factor(data_sem$Data) 



# 修改模型：将Latitude和Elevation影响Temperature和Precipitation
mod_productivity <- lm(TP ~ AT + AP, data = data_sem)
mod_at <- lm(AT ~ Elevation + Latitude, data = data_sem)
mod_ap <- lm(AP ~ Elevation + Latitude, data = data_sem)


# 添加TP范围对BPR的影响
mod_range <- lm(TP_Range ~ TP, data = data_sem)  # TP Range对BPR类型的影响

# 创建二项逻辑回归模型来反映不同的BPR类型
mod_neglinear <- glm(NegLinear ~ TP + TP_Range, 
                       family = binomial(link = "logit"), data = data_sem)
mod_unimodal <- glm(Unimodal ~ TP + TP_Range, 
                      family = binomial(link = "logit"), data = data_sem)
mod_poslinear <- glm(PosLinear ~ TP + TP_Range, 
                       family = binomial(link = "logit"), data = data_sem)
mod_nonsignificant <- glm(NonSignificant ~ TP + TP_Range, 
                            family = binomial(link = "logit"), data = data_sem)


# 建立SEM模型：将所有模型结合起来
sem_model <- psem(
  mod_productivity,
  mod_at,
  mod_ap,
  mod_range, # 添加TP范围对BPR的影响
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)


# 检查拟合指标
fisherC(sem_model)
R21 = rsquared(sem_model)

# 提取路径系数
coefs <- coefs(sem_model)
print(coefs)

# 可视化模型
plot(sem_model)

```

#SEM Shannon
```{r}

library(piecewiseSEM)
library(dplyr)
library(readr)
library(ggplot2)
library(ggdag)
library(stringr)
library(e1071)

data=read.csv("D:/Desktop/Data/R/output/result_all.csv")

# First four: not TP, AP05-08: lack abundance, PP06: lack abundance.
data <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18","AP05","AP06","AP07","AP08","PP06")))
data_sem <- data %>% 
  select(Organism, Data, Area, Median_TP, Median_AT, Median_AP, Median_Elevation, Median_AL, Area, Relationship_Type_Shannon, TP_Range, AT_Range, AP_Range, Elevation_Range, AL_Range) %>%
  rename(
    TP = Median_TP,      # 生产力
    AT = Median_AT,                # 温度
    AP = Median_AP,                # 降水量
    Elevation = Median_Elevation,  # 海拔
    Latitude = Median_AL,          # 纬度
    Area = Area,                   # 面积
    Relationships = Relationship_Type_Shannon, # 关系类型
    TP_Range = TP_Range,           # 总磷范围
    AT_Range = AT_Range,           # 温度范围
    AP_Range = AP_Range,           # 降水范围
    Elevation_Range = Elevation_Range, # 海拔范围
    AL_Range = AL_Range            # 纬度范围
  ) %>%
  mutate(
    NegLinear = ifelse(Relationships == "Negative Linear", 1, 0),
    Unimodal = ifelse(Relationships == "Unimodal", 1, 0),
    PosLinear = ifelse(Relationships == "Positive Linear", 1, 0),
    NonSignificant = ifelse(Relationships == "Non-significant", 1, 0) # 添加 Non-significant
  ) %>%
  select(-Relationships)  # 删除原始 Relationships 列


# 修改模型：将Latitude和Elevation影响Temperature和Precipitation
mod_productivity <- lm(TP ~ AT + AP, data = data_sem)
mod_at <- lm(AT ~ Elevation + Latitude, data = data_sem)
mod_ap <- lm(AP ~ Elevation + Latitude, data = data_sem)

# 添加TP范围对BPR的影响
mod_range <- lm(TP_Range ~ TP, data = data_sem)  # TP Range对BPR类型的影响

# 创建二项逻辑回归模型来反映不同的BPR类型
mod_neglinear <- glm(NegLinear ~ TP + TP_Range, 
                       family = binomial(link = "logit"), data = data_sem)
mod_unimodal <- glm(Unimodal ~ TP + TP_Range, 
                      family = binomial(link = "logit"), data = data_sem)
mod_poslinear <- glm(PosLinear ~ TP + TP_Range , 
                       family = binomial(link = "logit"), data = data_sem)
mod_nonsignificant <- glm(NonSignificant ~ TP + TP_Range , 
                            family = binomial(link = "logit"), data = data_sem)


# 建立SEM模型：将所有模型结合起来
sem_model <- psem(
  mod_productivity,
  mod_at,
  mod_ap,
  mod_range, # 添加TP范围对BPR的影响
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)



# 检查拟合指标
fisherC(sem_model)
R21 = rsquared(sem_model)

# 提取路径系数
coefs <- coefs(sem_model)
print(coefs)

# 可视化模型
plot(sem_model)
```


#SEM FD
```{r}
library(piecewiseSEM)
library(dplyr)
library(readr)
library(ggplot2)
library(ggdag)
library(stringr)
library(e1071)

data=read.csv("D:/Desktop/Data/R/output/result_all.csv")


data <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18","BM11","AP05","AP06","AP07","AP08")))
data_sem <- data %>% 
  select(Organism, Data, Area, Median_TP, Median_AT, Median_AP, Median_Elevation, Median_AL, Area, Relationship_Type_FRic, TP_Range, AT_Range, AP_Range, Elevation_Range, AL_Range) %>%
  rename(
    Productivity = Median_TP,      # 生产力
    AT = Median_AT,                # 温度
    AP = Median_AP,                # 降水量
    Elevation = Median_Elevation,  # 海拔
    Latitude = Median_AL,          # 纬度
    Area = Area,                   # 面积
    Relationships = Relationship_Type_FRic, # 关系类型
    TP_Range = TP_Range,           # 总磷范围
    AT_Range = AT_Range,           # 温度范围
    AP_Range = AP_Range,           # 降水范围
    Elevation_Range = Elevation_Range, # 海拔范围
    AL_Range = AL_Range            # 纬度范围
  ) %>%
  mutate(
    NegLinear = ifelse(Relationships == "Negative Linear", 1, 0),
    Unimodal = ifelse(Relationships == "Unimodal", 1, 0),
    PosLinear = ifelse(Relationships == "Positive Linear", 1, 0),
    NonSignificant = ifelse(Relationships == "Non-significant", 1, 0) # 添加 Non-significant
  ) %>%
  select(-Relationships)  # 删除原始 Relationships 列



# 检查数据
head(data_sem)
str(data_sem)

# 修改模型：将Latitude和Elevation影响Temperature和Precipitation
mod_productivity <- lm(Productivity ~ AT + AP, data = data_sem)
mod_at <- lm(AT ~ Elevation + Latitude, data = data_sem)
mod_ap <- lm(AP ~ Elevation + Latitude, data = data_sem)

# 添加TP范围对BPR的影响
mod_range <- lm(TP_Range ~ Productivity, data = data_sem)  # TP Range对BPR类型的影响

# 创建二项逻辑回归模型来反映不同的BPR类型
mod_neglinear <- glm(NegLinear ~ Productivity + TP_Range, 
                       family = binomial(link = "logit"), data = data_sem)
mod_unimodal <- glm(Unimodal ~ Productivity + TP_Range, 
                      family = binomial(link = "logit"), data = data_sem)
mod_poslinear <- glm(PosLinear ~ Productivity + TP_Range , 
                       family = binomial(link = "logit"), data = data_sem)
mod_nonsignificant <- glm(NonSignificant ~ Productivity + TP_Range , 
                            family = binomial(link = "logit"), data = data_sem)


# 建立SEM模型：将所有模型结合起来
sem_model <- psem(
  mod_productivity,
  mod_at,
  mod_ap,
  mod_range, # 添加TP范围对BPR的影响
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)

# 检查拟合指标
fisherC(sem_model)
R21 = rsquared(sem_model)

# 提取路径系数
coefs <- coefs(sem_model)
print(coefs)

# 可视化模型
plot(sem_model)
```

#SEM FDis
```{r}

library(piecewiseSEM)
library(dplyr)
library(readr)
library(ggplot2)
library(ggdag)
library(stringr)
library(e1071)

data=read.csv("D:/Desktop/Data/R/output/result_all.csv")


data <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD20", "BD18","AP05","AP06","AP07","AP08","PP06")))
data_sem <- data %>% 
  select(Organism, Data, Area, Median_TP, Median_AT, Median_AP, Median_Elevation, Median_AL, Area, Relationship_Type_FDis, TP_Range, AT_Range, AP_Range, Elevation_Range, AL_Range) %>%
  rename(
    TP = Median_TP,      # 生产力
    AT = Median_AT,                # 温度
    AP = Median_AP,                # 降水量
    Elevation = Median_Elevation,  # 海拔
    Latitude = Median_AL,          # 纬度
    Area = Area,                   # 面积
    Relationships = Relationship_Type_FDis, # 关系类型
    TP_Range = TP_Range,           # 总磷范围
    AT_Range = AT_Range,           # 温度范围
    AP_Range = AP_Range,           # 降水范围
    Elevation_Range = Elevation_Range, # 海拔范围
    AL_Range = AL_Range            # 纬度范围
  ) %>%
  mutate(
    NegLinear = ifelse(Relationships == "Negative Linear", 1, 0),
    Unimodal = ifelse(Relationships == "Unimodal", 1, 0),
    PosLinear = ifelse(Relationships == "Positive Linear", 1, 0),
    NonSignificant = ifelse(Relationships == "Non-significant", 1, 0) # 添加 Non-significant
  ) %>%
  select(-Relationships)  # 删除原始 Relationships 列


# 修改模型：将Latitude和Elevation影响Temperature和Precipitation
mod_productivity <- lm(TP ~ AT + AP, data = data_sem)
mod_at <- lm(AT ~ Elevation + Latitude, data = data_sem)
mod_ap <- lm(AP ~ Elevation + Latitude, data = data_sem)

# 添加TP范围对BPR的影响
mod_range <- lm(TP_Range ~ TP, data = data_sem)  # TP Range对BPR类型的影响

# 创建二项逻辑回归模型来反映不同的BPR类型
mod_neglinear <- glm(NegLinear ~ TP + TP_Range, 
                       family = binomial(link = "logit"), data = data_sem)
mod_unimodal <- glm(Unimodal ~ TP + TP_Range, 
                      family = binomial(link = "logit"), data = data_sem)
mod_poslinear <- glm(PosLinear ~ TP + TP_Range , 
                       family = binomial(link = "logit"), data = data_sem)
mod_nonsignificant <- glm(NonSignificant ~ TP + TP_Range , 
                            family = binomial(link = "logit"), data = data_sem)


# 建立SEM模型：将所有模型结合起来
sem_model <- psem(
  mod_productivity,
  mod_at,
  mod_ap,
  mod_range, # 添加TP范围对BPR的影响
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)



# 检查拟合指标
fisherC(sem_model)
R21 = rsquared(sem_model)

# 提取路径系数
coefs <- coefs(sem_model)
print(coefs)

# 可视化模型
plot(sem_model)
```



# SEM_median
```{r}

library(piecewiseSEM)
library(dplyr)
library(readr)
library(ggplot2)
library(ggdag)
library(stringr)
library(e1071)

data=read.csv("D:/Desktop/Data/R/output/result_all.csv")


data <- data %>%
  filter(!(Dataset %in% c("BM23", "BM24", "BD21","BD19")))

data_sem <- data %>% 
  select(Organism, Data, Area, Median_TP, Median_AT, Median_AP, Median_Elevation, Median_AL, Area, Relationship_Type) %>%
  rename(
    Productivity = Median_TP,      # 生产力
    AT = Median_AT,                # 温度
    AP = Median_AP,                # 降水量
    Elevation = Median_Elevation,  # 海拔
    Latitude = Median_AL,          # 纬度
    Area = Area,                   # 面积
    Relationships = Relationship_Type # 关系类型
  ) %>%
  mutate(
    Diversity_NegLinear = ifelse(Relationships == "Negative Linear", 1, 0),
    Diversity_Unimodal = ifelse(Relationships == "Unimodal", 1, 0),
    Diversity_PosLinear = ifelse(Relationships == "Positive Linear", 1, 0),
    Diversity_NonSignificant = ifelse(Relationships == "Non-significant", 1, 0) # 添加 Non-significant
  ) %>%
  select(-Relationships)  # 删除原始 Relationships 列

data_sem <- data_sem %>%
  mutate(
    Productivity = scale(log(Productivity)),  # 生产力取对数
    AT = scale(AT),                        # 标准化温度
    AP = scale(AP),                      # 降水量取对数（如果偏态明显）
    Elevation = scale(Elevation),          # 标准化海拔
    Latitude = scale(Latitude)             # 标准化纬度
  )


# 检查数据
head(data_sem)

str(data_sem)

mod_productivity <- lm(Productivity ~ AT + AP, data = data_sem)
mod_at <- lm(AT ~ Elevation + Latitude, data = data_sem)
mod_ap <- lm(AP ~ Elevation + Latitude, data = data_sem)
mod_neglinear <- glm(Diversity_NegLinear ~ Productivity, 
                       family = binomial(link = "logit"), data = data_sem)
mod_unimodal <- glm(Diversity_Unimodal ~ Productivity, 
                      family = binomial(link = "logit"), data = data_sem)
mod_poslinear <- glm(Diversity_PosLinear ~ Productivity , 
                       family = binomial(link = "logit"), data = data_sem)
mod_nonsignificant <- glm(Diversity_NonSignificant ~ Productivity , 
                            family = binomial(link = "logit"), data = data_sem)

sem_model <- psem(
  mod_productivity,
  mod_at,
  mod_ap,
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)


# 检查拟合指标
fisherC(sem_model)
R21=rsquared(sem_model)

# 提取路径系数
coefs <- coefs(sem_model)
print(coefs)
plot(sem_model)


```



# SEM_range
```{r}

data_sem <- data %>% 
  select(Organism, Data, Area, TP_Range, AT_Range, AP_Range, Elevation_Range, AL_Range, Area, Relationship_Type) %>%
  rename(
    Productivity = TP_Range,      # 生产力
    AT = AT_Range,                # 温度
    AP = AP_Range,                # 降水量
    Elevation = Elevation_Range,  # 海拔
    Latitude = AL_Range,          # 纬度
    Area = Area,                   # 面积
    Relationships = Relationship_Type # 关系类型
  ) %>%
  # 创建虚拟变量
  mutate(
    Diversity_NegLinear = ifelse(Relationships == "Negative Linear", 1, 0),
    Diversity_Unimodal = ifelse(Relationships == "Unimodal", 1, 0),
    Diversity_PosLinear = ifelse(Relationships == "Positive Linear", 1, 0),
    Diversity_NonSignificant = ifelse(Relationships == "Non-significant", 1, 0)
  ) %>%
  # 删除原始的 Relationships 列
  select(-Relationships)

head(data_sem)


mod_productivity <- lm(Productivity ~ AT + AP, data = data_sem)
#mod_productivity <- lm(Productivity ~ AT + AP + Elevation + Latitude, data = data_sem)
mod_at <- lm(AT ~ Elevation + Latitude, data = data_sem)
mod_ap <- lm(AP ~ Elevation + Latitude, data = data_sem)
mod_neglinear <- glm(Diversity_NegLinear ~ Productivity, 
                       family = binomial(link = "logit"), data = data_sem)
mod_unimodal <- glm(Diversity_Unimodal ~ Productivity , 
                      family = binomial(link = "logit"), data = data_sem)
mod_poslinear <- glm(Diversity_PosLinear ~ Productivity , 
                       family = binomial(link = "logit"), data = data_sem)
mod_nonsignificant <- glm(Diversity_NonSignificant ~ Productivity , 
                            family = binomial(link = "logit"), data = data_sem)
# 组合模型
sem_model <- psem(
  mod_productivity,
  mod_at,
  mod_ap,
  mod_neglinear,
  mod_unimodal,
  mod_poslinear,
  mod_nonsignificant
)


# 检查拟合指标
fisherC(sem_model)
R22=rsquared(sem_model)

coefs2 <- coefs(sem_model)

# 检查路径系数
print(coefs)
plot(sem_model)


```

# site
```{r}
library(tidyverse)
library(sf)
library(jsonlite)

dat=read.csv("D:/Desktop/Data/R/output/Coord.csv")

dat <- dat %>%
  mutate(Organism = ifelse(Organism == "Benthic Diatom", "Benthic Diatoms", Organism))
dat <- dat %>%
  mutate(Organism = ifelse(Organism == "Aquatic Plant", "Aquatic Plants", Organism))
dat <- dat %>%
  mutate(Organism = ifelse(Organism == "Benthic Macroinvertebrate", "Benthic Macroinvertebrates", Organism))

dat_rob <- dat %>%
  filter(!is.na(X), !is.na(Y)) %>%
  sf::st_as_sf(coords = c("X", "Y"), crs = 4326) %>%  # 经纬度坐标
  sf::st_transform(crs = sf::st_crs("+proj=robin +lon_0=0 +datum=WGS84 +units=m +no_defs")) %>%
  slice_sample(prop = 1)

# 关闭 s2 几何（避免部分空间操作报错）
sf::sf_use_s2(FALSE)

# 读取世界地图 shapefile
world_map <- sf::read_sf("D:/Desktop/Data/R/output/shp/TM_WORLD_BORDERS_SIMPL-0.3.shp") %>%
  sf::st_cast("POLYGON") %>%
  mutate(area = sf::st_area(geometry)) %>%
  filter(as.numeric(area) > 10^9) %>%
  sf::st_buffer(0) %>%
  sf::st_crop(sf::st_bbox(c(xmin = -180, xmax = 180, ymin = -90, ymax = 90))) %>%
  sf::st_transform(crs = sf::st_crs("+proj=robin +lon_0=0 +datum=WGS84 +units=m +no_defs"))


dat_rob$Organism <- factor(dat_rob$Organism, levels = c(
  "Aquatic Plants",
  "Fish",
  "Benthic Diatoms",
  "Phytoplankton",
  "Benthic Macroinvertebrates",
  "Zooplankton"
))

ggplot() + geom_sf(data = world_map)

ggplot() +
  geom_sf(data = world_map, fill = "grey90", color = "grey80") +
  geom_sf(data = dat_rob, aes(color = Organism), shape = 17, size = 1.2, alpha = 0.4) +
  scale_color_manual(values = c(
  "Aquatic Plant" = "#d8d4f2",
  "Fish" = "#4a68c4",
  "Benthic Diatom" = "#b0aee0",
  "Phytoplankton" = "#1d4db3",
  "Benthic Macroinvertebrate" = "#7e8ccf",
  "Zooplankton" = "#002f8c"
  )) +
  scale_x_continuous(breaks = seq(-180, 180, 45)) +
  theme_minimal() +
  theme(
    axis.text = element_blank(),
    axis.title = element_blank(),
    plot.title = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank(),
    plot.margin = margin(0, 0, 0, 0)
  )


ggsave("D:/Desktop/Data/R/output/site_map.pdf", width = 5, height = 3, dpi = 300)

```

# num
```{r}
library(ggplot2)
library(dplyr)
library(sf)
library(rnaturalearth)
library(maps)
library(cowplot)

dat=read.csv("D:/Desktop/Data/R/output/Coord.csv")

organism_count <- dat %>%
  count(Organism, name = "Sites") %>%
  arrange(desc(Sites))

# 反转因子顺序，从上到下显示从多到少
organism_count$Organism <- factor(organism_count$Organism, levels = rev(organism_count$Organism))

# 绘图

ggplot(organism_count, aes(x = Sites, y = Organism, fill = Sites)) +
  geom_bar(stat = "identity", width = 0.7) +
  scale_fill_gradient(low = "#fca5a5", high = "#7f1d1d") +
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(organism_count$Sites) * 1.05)) +
  labs(x = "Number of study sites", y = "", title = "") +   # ✅ 添加 x 轴标题
  theme_classic(base_size = 12) +
  theme(
    legend.position = "none",
    axis.text.x = element_text(size = 10, color = "black"),
    axis.text.y = element_text(size = 11, color = "black"),
    axis.title.x = element_text(size = 12, margin = margin(t = 10)),  # 适当与刻度线间距
    axis.line.y = element_line(color = "black", size = 0.6),
    axis.line.x = element_line(color = "black", size = 0.6),
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    panel.grid.major.x = element_line(color = "gray90", size = 0.4),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank()
  )




continent_count <- dat %>%
  count(continent, name = "Sites") %>%
  rename(Continent = continent) %>%  # 统一变量名为大写 Continent
  arrange(desc(Sites)) %>%
  mutate(Continent = factor(Continent, levels = rev(Continent)))

# 绘图
ggplot(continent_count, aes(x = Sites, y = Continent, fill = Sites)) +
  geom_bar(stat = "identity", width = 0.7) +
 scale_fill_gradient(low = "#cfe2f3", high = "#08306b")+
  scale_x_continuous(expand = c(0, 0), limits = c(0, max(continent_count$Sites) * 1.05)) +
  labs(x = "Number of study sites", y = "", title = "") +
  theme_classic(base_size = 12) +
  theme(
    legend.position = "none",  # 无图例
    axis.text.x = element_text(size = 10, color = "black"),
    axis.text.y = element_text(size = 11, color = "black"),
    axis.title.x = element_text(size = 12, margin = margin(t = 10)),
    axis.line.y = element_line(color = "black", size = 0.6),
    axis.line.x = element_line(color = "black", size = 0.6),
    axis.ticks.y = element_line(color = "black"),
    axis.ticks.x = element_line(color = "black"),
    panel.grid.major.x = element_line(color = "gray90", size = 0.4),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank()
  )





```

